diff --git a/setup.py b/setup.py
index 1a273ea..c80ec7e 100644
--- a/setup.py
+++ b/setup.py
@@ -192,7 +192,9 @@ if __name__ == "__main__":
             #keywords='',
             install_requires=['msgpack-python'],
             extras_require={
-                'qrcode': ['qrcode']
+                'qrcode': ['qrcode'],
+                'notify2': ['pygobject', 'notify2'],
+                'sound:platform_system=="Windows"': ['winsound']
             },
             classifiers=[
                 "License :: OSI Approved :: MIT License"
@@ -225,9 +227,18 @@ if __name__ == "__main__":
                     'popMenuYourIdentities.qrcode = '
                     'pybitmessage.plugins.qrcodeui [qrcode]'
                 ],
-            #    'console_scripts': [
-            #        'pybitmessage = pybitmessage.bitmessagemain:main'
-            #    ]
+                'notification.message': [
+                    'notify2 = pybitmessage.plugins.notification_notify2'
+                    '[notify2]'
+                ],
+                'notification.sound': [
+                    'file.phonon = pybitmessage.plugins.sound_phonon',
+                    'file.fallback = pybitmessage.plugins.sound_playfile'
+                    '[sound]'
+                ],
+                # 'console_scripts': [
+                #        'pybitmessage = pybitmessage.bitmessagemain:main'
+                # ]
             },
             scripts=['src/pybitmessage']
         )
@@ -235,4 +246,3 @@ if __name__ == "__main__":
         print "It looks like building the package failed.\n" \
             "You may be missing a C++ compiler and the OpenSSL headers."
         compilerToPackages()
-
diff --git a/src/bitmessageqt/__init__.py b/src/bitmessageqt/__init__.py
index feaf1c4..705e771 100644
--- a/src/bitmessageqt/__init__.py
+++ b/src/bitmessageqt/__init__.py
@@ -4,8 +4,6 @@ try:
     import gi
     gi.require_version('MessagingMenu', '1.0')
     from gi.repository import MessagingMenu
-    gi.require_version('Notify', '0.7')
-    from gi.repository import Notify
     withMessagingMenu = True
 except (ImportError, ValueError):
     MessagingMenu = None
@@ -62,9 +60,8 @@ import platform
 import textwrap
 import debug
 import random
-import subprocess
 import string
-import datetime
+from datetime import datetime, timedelta
 from helper_sql import *
 import helper_search
 import l10n
@@ -87,9 +84,10 @@ import state
 from statusbar import BMStatusBar
 import throttle
 from version import softwareVersion
+import sound
 
 try:
-    from plugins.plugin import get_plugins
+    from plugins.plugin import get_plugin, get_plugins
 except ImportError:
     get_plugins = False
 
@@ -144,16 +142,8 @@ def change_translation(newlocale):
 
 class MyForm(settingsmixin.SMainWindow):
 
-    # sound type constants
-    SOUND_NONE = 0
-    SOUND_KNOWN = 1
-    SOUND_UNKNOWN = 2
-    SOUND_CONNECTED = 3
-    SOUND_DISCONNECTED = 4
-    SOUND_CONNECTION_GREEN = 5
-
     # the last time that a message arrival sound was played
-    lastSoundTime = datetime.datetime.now() - datetime.timedelta(days=1)
+    lastSoundTime = datetime.now() - timedelta(days=1)
 
     # the maximum frequency of message sounds in seconds
     maxSoundFrequencySec = 60
@@ -1365,124 +1355,108 @@ class MyForm(settingsmixin.SMainWindow):
         # update the menu entries
         self.ubuntuMessagingMenuUnread(drawAttention)
 
-    # returns true if the given sound category is a connection sound
-    # rather than a received message sound
-    def isConnectionSound(self, category):
-        if (category is self.SOUND_CONNECTED or
-            category is self.SOUND_DISCONNECTED or
-            category is self.SOUND_CONNECTION_GREEN):
-            return True
-        return False
-
     # play a sound
     def playSound(self, category, label):
         # filename of the sound to be played
         soundFilename = None
 
-        # whether to play a sound or not
-        play = True
+        def _choose_ext(basename):
+            for ext in ('.wav', '.mp3', '.oga'):
+                if os.path.isfile(basename + ext):
+                    return ext
 
         # if the address had a known label in the address book
-        if label is not None:
+        if label:
             # Does a sound file exist for this particular contact?
-            if (os.path.isfile(state.appdata + 'sounds/' + label + '.wav') or
-                os.path.isfile(state.appdata + 'sounds/' + label + '.mp3')):
-                soundFilename = state.appdata + 'sounds/' + label
-
-        # Avoid making sounds more frequently than the threshold.
-        # This suppresses playing sounds repeatedly when there
-        # are many new messages
-        if (soundFilename is None and
-            not self.isConnectionSound(category)):
-            # elapsed time since the last sound was played
-            dt = datetime.datetime.now() - self.lastSoundTime
-            # suppress sounds which are more frequent than the threshold
-            if dt.total_seconds() < self.maxSoundFrequencySec:
-                play = False
+            soundFilename = state.appdata + 'sounds/' + label
+            ext = _choose_ext(soundFilename)
+            if not ext:
+                category = sound.SOUND_KNOWN
+                soundFilename = None
 
         if soundFilename is None:
+            # Avoid making sounds more frequently than the threshold.
+            # This suppresses playing sounds repeatedly when there
+            # are many new messages
+            if not sound.is_connection_sound(category):
+                # elapsed time since the last sound was played
+                dt = datetime.now() - self.lastSoundTime
+                # suppress sounds which are more frequent than the threshold
+                if dt.total_seconds() < self.maxSoundFrequencySec:
+                    return
+
             # the sound is for an address which exists in the address book
-            if category is self.SOUND_KNOWN:
+            if category is sound.SOUND_KNOWN:
                 soundFilename = state.appdata + 'sounds/known'
             # the sound is for an unknown address
-            elif category is self.SOUND_UNKNOWN:
+            elif category is sound.SOUND_UNKNOWN:
                 soundFilename = state.appdata + 'sounds/unknown'
             # initial connection sound
-            elif category is self.SOUND_CONNECTED:
+            elif category is sound.SOUND_CONNECTED:
                 soundFilename = state.appdata + 'sounds/connected'
             # disconnected sound
-            elif category is self.SOUND_DISCONNECTED:
+            elif category is sound.SOUND_DISCONNECTED:
                 soundFilename = state.appdata + 'sounds/disconnected'
             # sound when the connection status becomes green
-            elif category is self.SOUND_CONNECTION_GREEN:
-                soundFilename = state.appdata + 'sounds/green'            
+            elif category is sound.SOUND_CONNECTION_GREEN:
+                soundFilename = state.appdata + 'sounds/green'
 
-        if soundFilename is not None and play is True:
-            if not self.isConnectionSound(category):
-                # record the last time that a received message sound was played
-                self.lastSoundTime = datetime.datetime.now()
+        if soundFilename is None:
+            logger.warning("Probably wrong category number in playSound()")
+            return
 
-            # if not wav then try mp3 format
-            if not os.path.isfile(soundFilename + '.wav'):
-                soundFilename = soundFilename + '.mp3'
-            else:
-                soundFilename = soundFilename + '.wav'
+        if not sound.is_connection_sound(category):
+            # record the last time that a received message sound was played
+            self.lastSoundTime = datetime.now()
+
+        try:  # try already known format
+            soundFilename += ext
+        except (TypeError, NameError):
+            ext = _choose_ext(soundFilename)
+            if not ext:
+                try:  # if no user sound file found try to play from theme
+                    return self._theme_player(category, label)
+                except TypeError:
+                    return
 
-            if os.path.isfile(soundFilename):
-                if 'linux' in sys.platform:
-                    # Note: QSound was a nice idea but it didn't work
-                    if '.mp3' in soundFilename:
-                        gst_available=False
-                        try:
-                            subprocess.call(["gst123", soundFilename],
-                                            stdin=subprocess.PIPE, 
-                                            stdout=subprocess.PIPE)
-                            gst_available=True
-                        except:
-                            logger.warning("WARNING: gst123 must be installed in order to play mp3 sounds")
-                        if not gst_available:
-                            try:
-                                subprocess.call(["mpg123", soundFilename],
-                                                stdin=subprocess.PIPE, 
-                                                stdout=subprocess.PIPE)
-                                gst_available=True
-                            except:
-                                logger.warning("WARNING: mpg123 must be installed in order to play mp3 sounds")
-                    else:
-                        try:
-                            subprocess.call(["aplay", soundFilename],
-                                            stdin=subprocess.PIPE, 
-                                            stdout=subprocess.PIPE)
-                        except:
-                            logger.warning("WARNING: aplay must be installed in order to play WAV sounds")
-                elif sys.platform[0:3] == 'win':
-                    # use winsound on Windows
-                    import winsound
-                    winsound.PlaySound(soundFilename, winsound.SND_FILENAME)
+            soundFilename += ext
+
+        self._player(soundFilename)
 
     # initialise the message notifier
     def notifierInit(self):
-        if withMessagingMenu:
-            Notify.init('pybitmessage')
+        def _simple_notify(
+                title, subtitle, category, label=None, icon=None):
+            self.tray.showMessage(title, subtitle, 1, 2000)
 
-    # shows a notification
-    def notifierShow(self, title, subtitle, fromCategory, label):
-        self.playSound(fromCategory, label)
+        self._notifier = _simple_notify
+        # does nothing if isAvailable returns false
+        self._player = QtGui.QSound.play
 
-        if withMessagingMenu:
-            n = Notify.Notification.new(
-                title, subtitle, 'notification-message-email')
-            try:
-                n.show()
-            except:
-                # n.show() has been known to throw this exception:
-                # gi._glib.GError: GDBus.Error:org.freedesktop.Notifications.
-                # MaxNotificationsExceeded: Exceeded maximum number of
-                # notifications
-                pass
+        if not get_plugins:
             return
+
+        _plugin = get_plugin('notification.message')
+        if _plugin:
+            self._notifier = _plugin
         else:
-            self.tray.showMessage(title, subtitle, 1, 2000)
+            logger.warning("No notification.message plugin found")
+
+        self._theme_player = get_plugin('notification.sound', 'theme')
+
+        if not QtGui.QSound.isAvailable():
+            _plugin = get_plugin(
+                'notification.sound', 'file', fallback='file.fallback')
+            if _plugin:
+                self._player = _plugin
+            else:
+                logger.warning("No sound notification.sound plugin found")
+
+    def notifierShow(
+            self, title, subtitle, category, label=None, icon=None):
+        self.playSound(category, label)
+        self._notifier(
+            unicode(title), unicode(subtitle), category, label, icon)
 
     # tree
     def treeWidgetKeyPressEvent(self, event):
@@ -1662,15 +1636,18 @@ class MyForm(settingsmixin.SMainWindow):
 
     def setStatusIcon(self, color):
         # print 'setting status icon color'
+        _notifications_enabled = not BMConfigParser().getboolean(
+            'bitmessagesettings', 'hidetrayconnectionnotifications')
         if color == 'red':
             self.pushButtonStatusIcon.setIcon(
                 QIcon(":/newPrefix/images/redicon.png"))
             shared.statusIconColor = 'red'
             # if the connection is lost then show a notification
-            if self.connected and not BMConfigParser().getboolean('bitmessagesettings', 'hidetrayconnectionnotifications'):
-                self.notifierShow('Bitmessage', unicode(_translate(
-                            "MainWindow", "Connection lost").toUtf8(),'utf-8'),
-                                  self.SOUND_DISCONNECTED, None)
+            if self.connected and _notifications_enabled:
+                self.notifierShow(
+                    'Bitmessage',
+                    _translate("MainWindow", "Connection lost"),
+                    sound.SOUND_DISCONNECTED)
             if not BMConfigParser().safeGetBoolean('bitmessagesettings', 'upnp') and \
                 BMConfigParser().get('bitmessagesettings', 'socksproxytype') == "none":
                 self.statusBar().showMessage(_translate(
@@ -1688,10 +1665,11 @@ class MyForm(settingsmixin.SMainWindow):
                 ":/newPrefix/images/yellowicon.png"))
             shared.statusIconColor = 'yellow'
             # if a new connection has been established then show a notification
-            if not self.connected and not BMConfigParser().getboolean('bitmessagesettings', 'hidetrayconnectionnotifications'):
-                self.notifierShow('Bitmessage', unicode(_translate(
-                            "MainWindow", "Connected").toUtf8(),'utf-8'),
-                                  self.SOUND_CONNECTED, None)
+            if not self.connected and _notifications_enabled:
+                self.notifierShow(
+                    'Bitmessage',
+                    _translate("MainWindow", "Connected"),
+                    sound.SOUND_CONNECTED)
             self.connected = True
 
             if self.actionStatus is not None:
@@ -1704,10 +1682,11 @@ class MyForm(settingsmixin.SMainWindow):
             self.pushButtonStatusIcon.setIcon(
                 QIcon(":/newPrefix/images/greenicon.png"))
             shared.statusIconColor = 'green'
-            if not self.connected and not BMConfigParser().getboolean('bitmessagesettings', 'hidetrayconnectionnotifications'):
-                self.notifierShow('Bitmessage', unicode(_translate(
-                            "MainWindow", "Connected").toUtf8(),'utf-8'),
-                                  self.SOUND_CONNECTION_GREEN, None)
+            if not self.connected and _notifications_enabled:
+                self.notifierShow(
+                    'Bitmessage',
+                    _translate("MainWindow", "Connected"),
+                    sound.SOUND_CONNECTION_GREEN)
             self.connected = True
 
             if self.actionStatus is not None:
@@ -2248,8 +2227,14 @@ class MyForm(settingsmixin.SMainWindow):
         else:
             acct = ret
         self.propagateUnreadCount(acct.address)
-        if BMConfigParser().getboolean('bitmessagesettings', 'showtraynotifications'):
-            self.notifierShow(unicode(_translate("MainWindow",'New Message').toUtf8(),'utf-8'), unicode(_translate("MainWindow",'From ').toUtf8(),'utf-8') + unicode(acct.fromLabel, 'utf-8'), self.SOUND_UNKNOWN, None)
+        if BMConfigParser().getboolean(
+                'bitmessagesettings', 'showtraynotifications'):
+            self.notifierShow(
+                _translate("MainWindow", "New Message"),
+                _translate("MainWindow", "From %1").arg(
+                    unicode(acct.fromLabel, 'utf-8')),
+                sound.SOUND_UNKNOWN
+            )
         if self.getCurrentAccount() is not None and ((self.getCurrentFolder(treeWidget) != "inbox" and self.getCurrentFolder(treeWidget) is not None) or self.getCurrentAccount(treeWidget) != acct.address):
             # Ubuntu should notify of new message irespective of whether it's in current message list or not
             self.ubuntuMessagingMenuUpdate(True, None, acct.toLabel)
diff --git a/src/bitmessageqt/sound.py b/src/bitmessageqt/sound.py
new file mode 100644
index 0000000..4b6aaf0
--- /dev/null
+++ b/src/bitmessageqt/sound.py
@@ -0,0 +1,19 @@
+# -*- coding: utf-8 -*-
+
+# sound type constants
+SOUND_NONE = 0
+SOUND_KNOWN = 1
+SOUND_UNKNOWN = 2
+SOUND_CONNECTED = 3
+SOUND_DISCONNECTED = 4
+SOUND_CONNECTION_GREEN = 5
+
+
+# returns true if the given sound category is a connection sound
+# rather than a received message sound
+def is_connection_sound(category):
+    return category in (
+        SOUND_CONNECTED,
+        SOUND_DISCONNECTED,
+        SOUND_CONNECTION_GREEN
+    )
diff --git a/src/plugins/notification_notify2.py b/src/plugins/notification_notify2.py
new file mode 100644
index 0000000..90f09df
--- /dev/null
+++ b/src/plugins/notification_notify2.py
@@ -0,0 +1,13 @@
+# -*- coding: utf-8 -*-
+
+import gi
+gi.require_version('Notify', '0.7')
+from gi.repository import Notify
+
+Notify.init('pybitmessage')
+
+
+def connect_plugin(title, subtitle, category, label, icon):
+    if not icon:
+        icon = 'mail-message-new' if category == 2 else 'pybitmessage'
+    Notify.Notification.new(title, subtitle, icon).show()
diff --git a/src/plugins/plugin.py b/src/plugins/plugin.py
index 288be48..74c9fa6 100644
--- a/src/plugins/plugin.py
+++ b/src/plugins/plugin.py
@@ -3,10 +3,32 @@
 import pkg_resources
 
 
-def get_plugins(group, point, name=None):
-    for plugin in pkg_resources.iter_entry_points(group):
-        if plugin.name.startswith(point):
+def get_plugins(group, point='', name=None, fallback=None):
+    """
+    Iterate through plugins (`connect_plugin` attribute of entry point)
+    which name starts with `point` or equals to `name`.
+    If `fallback` kwarg specified, plugin with that name yield last.
+    """
+    for ep in pkg_resources.iter_entry_points(group):
+        if name and ep.name == name or ep.name.startswith(point):
             try:
-                yield plugin.load().connect_plugin
-            except (AttributeError, pkg_resources.DistributionNotFound):
+                plugin = ep.load().connect_plugin
+                if ep.name == fallback:
+                    _fallback = plugin
+                else:
+                    yield plugin
+            except (AttributeError,
+                    ImportError,
+                    pkg_resources.DistributionNotFound,
+                    pkg_resources.UnknownExtra):
                 continue
+    try:
+        yield _fallback
+    except NameError:
+        pass
+
+
+def get_plugin(*args, **kwargs):
+    """Returns first available plugin `from get_plugins()` if any."""
+    for plugin in get_plugins(*args, **kwargs):
+        return plugin
diff --git a/src/plugins/sound_playfile.py b/src/plugins/sound_playfile.py
new file mode 100644
index 0000000..c8216d0
--- /dev/null
+++ b/src/plugins/sound_playfile.py
@@ -0,0 +1,41 @@
+# -*- coding: utf-8 -*-
+
+
+try:
+    import winsound
+
+    def connect_plugin(sound_file):
+        winsound.PlaySound(sound_file, winsound.SND_FILENAME)
+except ImportError:
+    import os
+    import subprocess
+
+    play_cmd = {}
+
+    def _subprocess(*args):
+        FNULL = open(os.devnull, 'wb')
+        subprocess.call(
+            args, stdout=FNULL, stderr=subprocess.STDOUT, close_fds=True)
+
+    def connect_plugin(sound_file):
+        global play_cmd
+
+        ext = os.path.splitext(sound_file)[-1]
+        try:
+            return _subprocess(play_cmd[ext], sound_file)
+        except (KeyError, AttributeError):
+            pass
+
+        programs = ['gst123', 'gst-play-1.0']
+        if ext == '.wav':
+            programs.append('aplay')
+        elif ext == '.mp3':
+            programs += ['mpg123', 'mpg321', 'mpg321-mpg123']
+        for cmd in programs:
+            try:
+                _subprocess(cmd, sound_file)
+            except OSError:
+                pass  # log here!
+            else:
+                play_cmd[ext] = cmd
+                break

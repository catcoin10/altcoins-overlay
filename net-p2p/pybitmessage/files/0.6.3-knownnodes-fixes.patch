diff --git a/src/helper_bootstrap.py b/src/helper_bootstrap.py
index 0d207928..1710b09c 100644
--- a/src/helper_bootstrap.py
+++ b/src/helper_bootstrap.py
@@ -40,8 +40,8 @@ def dns():
                     port, exc_info=True
                 )
     elif proxy_type == 'SOCKS5':
-        knownnodes.addKnownNode(1, state.Peer('quzwelsuziwqgpt2.onion', 8444))
-        logger.debug("Adding quzwelsuziwqgpt2.onion:8444 to knownNodes.")
+        knownnodes.createDefaultKnownNodes(onion=True)
+        logger.debug('Adding default onion knownNodes.')
         for port in [8080, 8444]:
             logger.debug("Resolving %i through SOCKS...", port)
             address_family = socket.AF_INET
diff --git a/src/knownnodes.py b/src/knownnodes.py
index 08ab0551..6ccb7daa 100644
--- a/src/knownnodes.py
+++ b/src/knownnodes.py
@@ -21,6 +21,8 @@ knownNodesTrimAmount = 2000
 # forget a node after rating is this low
 knownNodesForgetRating = -0.5
 
+knownNodesActual = False
+
 DEFAULT_NODES = (
     state.Peer('5.45.99.75', 8444),
     state.Peer('75.167.159.54', 8444),
@@ -33,6 +35,10 @@ DEFAULT_NODES = (
     state.Peer('178.11.46.221', 8444)
 )
 
+DEFAULT_NODES_ONION = (
+    state.Peer('quzwelsuziwqgpt2.onion', 8444),
+)
+
 
 def json_serialize_knownnodes(output):
     """
@@ -52,10 +58,19 @@ def json_deserialize_knownnodes(source):
     """
     Read JSON from source and make knownnodes dict
     """
+    global knownNodesActual  # pylint: disable=global-statement
     for node in json.load(source):
         peer = node['peer']
-        peer['host'] = str(peer['host'])
-        knownNodes[node['stream']][state.Peer(**peer)] = node['info']
+        info = node['info']
+        peer = state.Peer(str(peer['host']), peer.get('port', 8444))
+        knownNodes[node['stream']][peer] = info
+
+        if (
+            not (knownNodesActual or info.get('is_self')) and
+            peer not in DEFAULT_NODES and
+            peer not in DEFAULT_NODES_ONION
+        ):
+            knownNodesActual = True
 
 
 def pickle_deserialize_old_knownnodes(source):
@@ -88,9 +103,10 @@ def addKnownNode(stream, peer, lastseen=None, is_self=False):
     }
 
 
-def createDefaultKnownNodes():
-    for peer in DEFAULT_NODES:
-        addKnownNode(1, peer)
+def createDefaultKnownNodes(onion=False):
+    past = time.time() - 2418600  # 28 days - 10 min
+    for peer in DEFAULT_NODES_ONION if onion else DEFAULT_NODES:
+        addKnownNode(1, peer, past)
     saveKnownNodes()
 
 
@@ -115,7 +131,9 @@ def readKnownNodes():
     if onionhostname and ".onion" in onionhostname:
         onionport = config.safeGetInt('bitmessagesettings', 'onionport')
         if onionport:
-            addKnownNode(1, state.Peer(onionhostname, onionport), is_self=True)
+            self_peer = state.Peer(onionhostname, onionport)
+            addKnownNode(1, self_peer, is_self=True)
+            state.ownAddresses[self_peer] = True
 
 
 def increaseRating(peer):
@@ -166,13 +184,20 @@ def cleanupKnownNodes():
     now = int(time.time())
     needToWriteKnownNodesToDisk = False
     dns_done = False
+    spawnConnections = not BMConfigParser().safeGetBoolean(
+        'bitmessagesettings', 'dontconnect'
+    ) and BMConfigParser().safeGetBoolean(
+        'bitmessagesettings', 'sendoutgoingconnections')
 
     with knownNodesLock:
         for stream in knownNodes:
+            if stream not in state.streamsInWhichIAmParticipating:
+                continue
             keys = knownNodes[stream].keys()
-            if len(keys) <= 1 and not dns_done:  # leave at least one node
-                dns()
-                dns_done = True
+            if len(keys) <= 1:  # leave at least one node
+                if not dns_done and spawnConnections:
+                    dns()
+                    dns_done = True
                 continue
             for node in keys:
                 try:
diff --git a/src/network/connectionpool.py b/src/network/connectionpool.py
index fa098411..e599cdfb 100644
--- a/src/network/connectionpool.py
+++ b/src/network/connectionpool.py
@@ -8,7 +8,7 @@ import re
 from bmconfigparser import BMConfigParser
 from debug import logger
 import helper_bootstrap
-from knownnodes import knownNodes
+import knownnodes
 from network.proxy import Proxy
 from network.tcp import TCPServer, Socks5BMConnection, Socks4aBMConnection, TCPConnection
 from network.udp import UDPSocket
@@ -19,6 +19,7 @@ from singleton import Singleton
 import state
 import helper_random
 
+
 @Singleton
 class BMConnectionPool(object):
     def __init__(self):
@@ -139,7 +140,7 @@ class BMConnectionPool(object):
             acceptConnections = False
 
         if spawnConnections:
-            if not any([knownNodes.iteritems()]):
+            if not knownnodes.knownNodesActual:
                 helper_bootstrap.dns()
             if not self.bootstrapped:
                 self.bootstrapped = True
diff --git a/src/network/bmproto.py b/src/network/bmproto.py
index 1f1c67bd..5333233d 100644
--- a/src/network/bmproto.py
+++ b/src/network/bmproto.py
@@ -381,14 +381,18 @@ class BMProto(AdvancedDispatcher, ObjectTracker):
             decodedIP = protocol.checkIPAddress(str(ip))
             if stream not in state.streamsInWhichIAmParticipating:
                 continue
-            if decodedIP is not False and seenTime > time.time() - BMProto.addressAlive:
+            if (
+                decodedIP and time.time() - seenTime > 0 and
+                seenTime > time.time() - BMProto.addressAlive and
+                port > 0
+            ):
                 peer = state.Peer(decodedIP, port)
                 try:
                     if knownnodes.knownNodes[stream][peer]["lastseen"] > seenTime:
                         continue
                 except KeyError:
                     pass
-                if len(knownnodes.knownNodes[stream]) < int(BMConfigParser().get("knownnodes", "maxnodes")):
+                if len(knownnodes.knownNodes[stream]) < BMConfigParser().safeGetInt("knownnodes", "maxnodes"):
                     with knownnodes.knownNodesLock:
                         try:
                             knownnodes.knownNodes[stream][peer]["lastseen"] = seenTime

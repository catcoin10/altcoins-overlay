diff --git a/setup.py b/setup.py
index 44356e7..9839071 100644
--- a/setup.py
+++ b/setup.py
@@ -124,6 +124,9 @@ if __name__ == "__main__":
                 'libmessaging ='
                 'pybitmessage.plugins.indicator_libmessaging [gir]'
             ],
+            'bitmessage.keystore': [
+                'gnomekeyring = pybitmessage.plugins.keystore_gnomekeyring'
+            ],
             # 'console_scripts': [
             #        'pybitmessage = pybitmessage.bitmessagemain:main'
             # ]
diff --git a/src/addresses.py b/src/addresses.py
index c8caaf8..ed07436 100644
--- a/src/addresses.py
+++ b/src/addresses.py
@@ -1,11 +1,12 @@
 import hashlib
-from struct import *
+from struct import pack, unpack
 from pyelliptic import arithmetic
 from binascii import hexlify, unhexlify
 
-#from debug import logger
+from debug import logger
 
-#There is another copy of this function in Bitmessagemain.py
+
+# There is another copy of this function in Bitmessagemain.py
 def convertIntToString(n):
     a = __builtins__.hex(n)
     if a[-1:] == 'L':
@@ -17,6 +18,7 @@ def convertIntToString(n):
 
 ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
 
+
 def encodeBase58(num, alphabet=ALPHABET):
     """Encode a number in Base X
 
@@ -29,12 +31,13 @@ def encodeBase58(num, alphabet=ALPHABET):
     base = len(alphabet)
     while num:
         rem = num % base
-        #print 'num is:', num
+        # print 'num is:', num
         num = num // base
         arr.append(alphabet[rem])
     arr.reverse()
     return ''.join(arr)
 
+
 def decodeBase58(string, alphabet=ALPHABET):
     """Decode a Base X encoded string into the number
 
@@ -44,73 +47,91 @@ def decodeBase58(string, alphabet=ALPHABET):
     """
     base = len(alphabet)
     num = 0
-    
+
     try:
         for char in string:
             num *= base
             num += alphabet.index(char)
-    except:
-        #character not found (like a space character or a 0)
+    except:  # ValueError
+        # character not found (like a space character or a 0)
         return 0
     return num
 
+
 def encodeVarint(integer):
     if integer < 0:
         logger.error('varint cannot be < 0')
         raise SystemExit
     if integer < 253:
-        return pack('>B',integer)
+        return pack('>B', integer)
     if integer >= 253 and integer < 65536:
-        return pack('>B',253) + pack('>H',integer)
+        return pack('>B', 253) + pack('>H', integer)
     if integer >= 65536 and integer < 4294967296:
-        return pack('>B',254) + pack('>I',integer)
+        return pack('>B', 254) + pack('>I', integer)
     if integer >= 4294967296 and integer < 18446744073709551616:
-        return pack('>B',255) + pack('>Q',integer)
+        return pack('>B', 255) + pack('>Q', integer)
     if integer >= 18446744073709551616:
         logger.error('varint cannot be >= 18446744073709551616')
         raise SystemExit
-    
+
+
 class varintDecodeError(Exception):
     pass
 
+
 def decodeVarint(data):
     """
-    Decodes an encoded varint to an integer and returns it. 
-    Per protocol v3, the encoded value must be encoded with 
-    the minimum amount of data possible or else it is malformed.    
+    Decodes an encoded varint to an integer and returns it.
+    Per protocol v3, the encoded value must be encoded with
+    the minimum amount of data possible or else it is malformed.
     Returns a tuple: (theEncodedValue, theSizeOfTheVarintInBytes)
     """
-    
+
     if len(data) == 0:
-        return (0,0)
-    firstByte, = unpack('>B',data[0:1])
+        return (0, 0)
+    firstByte, = unpack('>B', data[0:1])
     if firstByte < 253:
         # encodes 0 to 252
-        return (firstByte,1) #the 1 is the length of the varint
+        return (firstByte, 1)  # the 1 is the length of the varint
     if firstByte == 253:
         # encodes 253 to 65535
         if len(data) < 3:
-            raise varintDecodeError('The first byte of this varint as an integer is %s but the total length is only %s. It needs to be at least 3.' % (firstByte, len(data)))
-        encodedValue, = unpack('>H',data[1:3])
+            raise varintDecodeError(
+                'The first byte of this varint as an integer is %s'
+                ' but the total length is only %s. It needs to be'
+                ' at least 3.' % (firstByte, len(data)))
+        encodedValue, = unpack('>H', data[1:3])
         if encodedValue < 253:
-            raise varintDecodeError('This varint does not encode the value with the lowest possible number of bytes.')
-        return (encodedValue,3)
+            raise varintDecodeError(
+                'This varint does not encode the value with the lowest'
+                ' possible number of bytes.')
+        return (encodedValue, 3)
     if firstByte == 254:
         # encodes 65536 to 4294967295
         if len(data) < 5:
-            raise varintDecodeError('The first byte of this varint as an integer is %s but the total length is only %s. It needs to be at least 5.' % (firstByte, len(data)))
-        encodedValue, = unpack('>I',data[1:5])
+            raise varintDecodeError(
+                'The first byte of this varint as an integer is %s'
+                ' but the total length is only %s. It needs to be'
+                ' at least 5.' % (firstByte, len(data)))
+        encodedValue, = unpack('>I', data[1:5])
         if encodedValue < 65536:
-            raise varintDecodeError('This varint does not encode the value with the lowest possible number of bytes.')
-        return (encodedValue,5)
+            raise varintDecodeError(
+                'This varint does not encode the value with the lowest'
+                ' possible number of bytes.')
+        return (encodedValue, 5)
     if firstByte == 255:
         # encodes 4294967296 to 18446744073709551615
         if len(data) < 9:
-            raise varintDecodeError('The first byte of this varint as an integer is %s but the total length is only %s. It needs to be at least 9.' % (firstByte, len(data)))
-        encodedValue, = unpack('>Q',data[1:9])
+            raise varintDecodeError(
+                'The first byte of this varint as an integer is %s'
+                ' but the total length is only %s. It needs to be'
+                ' at least 9.' % (firstByte, len(data)))
+        encodedValue, = unpack('>Q', data[1:9])
         if encodedValue < 4294967296:
-            raise varintDecodeError('This varint does not encode the value with the lowest possible number of bytes.')
-        return (encodedValue,9)
+            raise varintDecodeError(
+                'This varint does not encode the value with the lowest'
+                ' possible number of bytes.')
+        return (encodedValue, 9)
 
 
 def calculateInventoryHash(data):
@@ -120,21 +141,27 @@ def calculateInventoryHash(data):
     sha2.update(sha.digest())
     return sha2.digest()[0:32]
 
-def encodeAddress(version,stream,ripe):
+
+def encodeAddress(version, stream, ripe):
     if version >= 2 and version < 4:
         if len(ripe) != 20:
-            raise Exception("Programming error in encodeAddress: The length of a given ripe hash was not 20.")
+            raise Exception(
+                'Programming error in encodeAddress: The length of'
+                ' a given ripe hash was not 20.'
+            )
         if ripe[:2] == '\x00\x00':
             ripe = ripe[2:]
         elif ripe[:1] == '\x00':
             ripe = ripe[1:]
     elif version == 4:
         if len(ripe) != 20:
-            raise Exception("Programming error in encodeAddress: The length of a given ripe hash was not 20.")
+            raise Exception(
+                'Programming error in encodeAddress: The length of'
+                ' a given ripe hash was not 20.')
         ripe = ripe.lstrip('\x00')
 
     storedBinaryData = encodeVarint(version) + encodeVarint(stream) + ripe
-    
+
     # Generate the checksum
     sha = hashlib.new('sha512')
     sha.update(storedBinaryData)
@@ -143,11 +170,13 @@ def encodeAddress(version,stream,ripe):
     sha.update(currentHash)
     checksum = sha.digest()[0:4]
 
-    asInt = int(hexlify(storedBinaryData) + hexlify(checksum),16)
-    return 'BM-'+ encodeBase58(asInt)
+    asInt = int(hexlify(storedBinaryData) + hexlify(checksum), 16)
+    return 'BM-' + encodeBase58(asInt)
+
 
 def decodeAddress(address):
-    #returns (status, address version number, stream number, data (almost certainly a ripe hash))
+    # returns (status, address version number, stream number,
+    # data (almost certainly a ripe hash))
 
     address = str(address).strip()
 
@@ -157,14 +186,15 @@ def decodeAddress(address):
         integer = decodeBase58(address)
     if integer == 0:
         status = 'invalidcharacters'
-        return status,0,0,""
-    #after converting to hex, the string will be prepended with a 0x and appended with a L
+        return status, 0, 0, ''
+    # after converting to hex, the string will be prepended
+    # with a 0x and appended with a L
     hexdata = hex(integer)[2:-1]
 
     if len(hexdata) % 2 != 0:
         hexdata = '0' + hexdata
 
-    #print 'hexdata', hexdata
+    # print 'hexdata', hexdata
 
     data = unhexlify(hexdata)
     checksum = data[-4:]
@@ -172,15 +202,15 @@ def decodeAddress(address):
     sha = hashlib.new('sha512')
     sha.update(data[:-4])
     currentHash = sha.digest()
-    #print 'sha after first hashing: ', sha.hexdigest()
+    # print 'sha after first hashing: ', sha.hexdigest()
     sha = hashlib.new('sha512')
     sha.update(currentHash)
-    #print 'sha after second hashing: ', sha.hexdigest()
+    # print 'sha after second hashing: ', sha.hexdigest()
 
     if checksum != sha.digest()[0:4]:
         status = 'checksumfailed'
-        return status,0,0,""
-    #else:
+        return status, 0, 0, ''
+    # else:
     #    print 'checksum PASSED'
 
     try:
@@ -188,95 +218,128 @@ def decodeAddress(address):
     except varintDecodeError as e:
         logger.error(str(e))
         status = 'varintmalformed'
-        return status,0,0,""
-    #print 'addressVersionNumber', addressVersionNumber
-    #print 'bytesUsedByVersionNumber', bytesUsedByVersionNumber
+        return status, 0, 0, ''
+    # print 'addressVersionNumber', addressVersionNumber
+    # print 'bytesUsedByVersionNumber', bytesUsedByVersionNumber
 
     if addressVersionNumber > 4:
         logger.error('cannot decode address version numbers this high')
         status = 'versiontoohigh'
-        return status,0,0,""
+        return status, 0, 0, ''
     elif addressVersionNumber == 0:
         logger.error('cannot decode address version numbers of zero.')
         status = 'versiontoohigh'
-        return status,0,0,""
+        return status, 0, 0, ''
 
     try:
-        streamNumber, bytesUsedByStreamNumber = decodeVarint(data[bytesUsedByVersionNumber:])
+        streamNumber, bytesUsedByStreamNumber = \
+          decodeVarint(data[bytesUsedByVersionNumber:])
     except varintDecodeError as e:
         logger.error(str(e))
         status = 'varintmalformed'
-        return status,0,0,""
-    #print streamNumber
+        return status, 0, 0, ''
+    # print streamNumber
     status = 'success'
     if addressVersionNumber == 1:
-        return status,addressVersionNumber,streamNumber,data[-24:-4]
+        return status, addressVersionNumber, streamNumber, data[-24:-4]
     elif addressVersionNumber == 2 or addressVersionNumber == 3:
-        embeddedRipeData = data[bytesUsedByVersionNumber+bytesUsedByStreamNumber:-4]
+        embeddedRipeData = \
+          data[bytesUsedByVersionNumber + bytesUsedByStreamNumber:-4]
         if len(embeddedRipeData) == 19:
-            return status,addressVersionNumber,streamNumber,'\x00'+embeddedRipeData
+            return status, addressVersionNumber, streamNumber, \
+              '\x00'+embeddedRipeData
         elif len(embeddedRipeData) == 20:
-            return status,addressVersionNumber,streamNumber,embeddedRipeData
+            return status, addressVersionNumber, streamNumber, \
+              embeddedRipeData
         elif len(embeddedRipeData) == 18:
-            return status,addressVersionNumber,streamNumber,'\x00\x00'+embeddedRipeData
+            return status, addressVersionNumber, streamNumber, \
+              '\x00\x00' + embeddedRipeData
         elif len(embeddedRipeData) < 18:
-            return 'ripetooshort',0,0,""
+            return 'ripetooshort', 0, 0, ''
         elif len(embeddedRipeData) > 20:
-            return 'ripetoolong',0,0,""
+            return 'ripetoolong', 0, 0, ''
         else:
-            return 'otherproblem',0,0,""
+            return 'otherproblem', 0, 0, ''
     elif addressVersionNumber == 4:
-        embeddedRipeData = data[bytesUsedByVersionNumber+bytesUsedByStreamNumber:-4]
+        embeddedRipeData = \
+          data[bytesUsedByVersionNumber + bytesUsedByStreamNumber:-4]
         if embeddedRipeData[0:1] == '\x00':
-            # In order to enforce address non-malleability, encoded RIPE data must have NULL bytes removed from the front
-            return 'encodingproblem',0,0,"" 
+            # In order to enforce address non-malleability, encoded
+            # RIPE data must have NULL bytes removed from the front
+            return 'encodingproblem', 0, 0, ''
         elif len(embeddedRipeData) > 20:
-            return 'ripetoolong',0,0,""
+            return 'ripetoolong', 0, 0, ''
         elif len(embeddedRipeData) < 4:
-            return 'ripetooshort',0,0,""
+            return 'ripetooshort', 0, 0, ''
         else:
             x00string = '\x00' * (20 - len(embeddedRipeData))
-            return status,addressVersionNumber,streamNumber,x00string+embeddedRipeData
+            return status, addressVersionNumber, streamNumber, \
+                x00string + embeddedRipeData
+
 
 def addBMIfNotPresent(address):
     address = str(address).strip()
-    if address[:3] != 'BM-':
-        return 'BM-'+address
-    else:
-        return address
+    return address if address[:3] == 'BM-' else 'BM-' + address
+
 
 if __name__ == "__main__":
-    print 'Let us make an address from scratch. Suppose we generate two random 32 byte values and call the first one the signing key and the second one the encryption key:'
-    privateSigningKey = '93d0b61371a54b53df143b954035d612f8efa8a3ed1cf842c2186bfd8f876665'
-    privateEncryptionKey = '4b0b73a54e19b059dc274ab69df095fe699f43b17397bca26fdf40f4d7400a3a'
-    print 'privateSigningKey =', privateSigningKey
-    print 'privateEncryptionKey =', privateEncryptionKey
-    print 'Now let us convert them to public keys by doing an elliptic curve point multiplication.'
+    print(
+        '\nLet us make an address from scratch. Suppose we generate two'
+        ' random 32 byte values and call the first one the signing key'
+        ' and the second one the encryption key:'
+    )
+    privateSigningKey = \
+        '93d0b61371a54b53df143b954035d612f8efa8a3ed1cf842c2186bfd8f876665'
+    privateEncryptionKey = \
+        '4b0b73a54e19b059dc274ab69df095fe699f43b17397bca26fdf40f4d7400a3a'
+    print(
+        '\nprivateSigningKey = %s\nprivateEncryptionKey = %s' %
+        (privateSigningKey, privateEncryptionKey)
+    )
+    print(
+        '\nNow let us convert them to public keys by doing'
+        ' an elliptic curve point multiplication.'
+    )
     publicSigningKey = arithmetic.privtopub(privateSigningKey)
     publicEncryptionKey = arithmetic.privtopub(privateEncryptionKey)
-    print 'publicSigningKey =', publicSigningKey
-    print 'publicEncryptionKey =', publicEncryptionKey
-
-    print 'Notice that they both begin with the \\x04 which specifies the encoding type. This prefix is not send over the wire. You must strip if off before you send your public key across the wire, and you must add it back when you receive a public key.'
-
-    publicSigningKeyBinary = arithmetic.changebase(publicSigningKey,16,256,minlen=64)
-    publicEncryptionKeyBinary = arithmetic.changebase(publicEncryptionKey,16,256,minlen=64)
+    print(
+        '\npublicSigningKey = %s\npublicEncryptionKey = %s' %
+        (publicSigningKey, publicEncryptionKey)
+    )
+
+    print(
+        '\nNotice that they both begin with the \\x04 which specifies'
+        ' the encoding type. This prefix is not send over the wire.'
+        ' You must strip if off before you send your public key across'
+        ' the wire, and you must add it back when you receive a public key.'
+    )
+
+    publicSigningKeyBinary = \
+        arithmetic.changebase(publicSigningKey, 16, 256, minlen=64)
+    publicEncryptionKeyBinary = \
+        arithmetic.changebase(publicEncryptionKey, 16, 256, minlen=64)
 
     ripe = hashlib.new('ripemd160')
     sha = hashlib.new('sha512')
-    sha.update(publicSigningKeyBinary+publicEncryptionKeyBinary)
+    sha.update(publicSigningKeyBinary + publicEncryptionKeyBinary)
 
     ripe.update(sha.digest())
     addressVersionNumber = 2
     streamNumber = 1
-    print 'Ripe digest that we will encode in the address:', hexlify(ripe.digest())
-    returnedAddress = encodeAddress(addressVersionNumber,streamNumber,ripe.digest())
-    print 'Encoded address:', returnedAddress
-    status,addressVersionNumber,streamNumber,data = decodeAddress(returnedAddress)
-    print '\nAfter decoding address:'
-    print 'Status:', status
-    print 'addressVersionNumber', addressVersionNumber
-    print 'streamNumber', streamNumber
-    print 'length of data(the ripe hash):', len(data)
-    print 'ripe data:', hexlify(data)
-
+    print(
+        '\nRipe digest that we will encode in the address: %s' %
+        hexlify(ripe.digest())
+    )
+    returnedAddress = \
+        encodeAddress(addressVersionNumber, streamNumber, ripe.digest())
+    print('Encoded address: %s' % returnedAddress)
+    status, addressVersionNumber, streamNumber, data = \
+        decodeAddress(returnedAddress)
+    print(
+        '\nAfter decoding address:\n\tStatus: %s'
+        '\n\taddressVersionNumber %s'
+        '\n\tstreamNumber %s'
+        '\n\tlength of data (the ripe hash): %s'
+        '\n\tripe data: %s' %
+        (status, addressVersionNumber, streamNumber, len(data), hexlify(data))
+    )
diff --git a/src/class_addressGenerator.py b/src/class_addressGenerator.py
index bd377c1..f43e7f6 100644
--- a/src/class_addressGenerator.py
+++ b/src/class_addressGenerator.py
@@ -1,21 +1,22 @@
-import shared
-import threading
+
 import time
-import sys
-from pyelliptic.openssl import OpenSSL
-import ctypes
+import threading
 import hashlib
-import highlevelcrypto
-from addresses import *
-from bmconfigparser import BMConfigParser
-from debug import logger
-import defaults
-from helper_threading import *
+from binascii import hexlify
 from pyelliptic import arithmetic
+from pyelliptic.openssl import OpenSSL
+
 import tr
-from binascii import hexlify
 import queues
 import state
+import shared
+import defaults
+import highlevelcrypto
+from bmconfigparser import BMConfigParser
+from debug import logger
+from addresses import decodeAddress, encodeAddress, encodeVarint
+from helper_threading import StoppableThread
+
 
 class addressGenerator(threading.Thread, StoppableThread):
 
@@ -23,7 +24,7 @@ class addressGenerator(threading.Thread, StoppableThread):
         # QThread.__init__(self, parent)
         threading.Thread.__init__(self, name="addressGenerator")
         self.initStop()
-        
+
     def stopThread(self):
         try:
             queues.addressGeneratorQueue.put(("stopThread", "data"))
@@ -38,66 +39,95 @@ class addressGenerator(threading.Thread, StoppableThread):
             payloadLengthExtraBytes = 0
             live = True
             if queueValue[0] == 'createChan':
-                command, addressVersionNumber, streamNumber, label, deterministicPassphrase, live = queueValue
+                command, addressVersionNumber, streamNumber, label, \
+                    deterministicPassphrase, live = queueValue
                 eighteenByteRipe = False
                 numberOfAddressesToMake = 1
                 numberOfNullBytesDemandedOnFrontOfRipeHash = 1
             elif queueValue[0] == 'joinChan':
-                command, chanAddress, label, deterministicPassphrase, live = queueValue
+                command, chanAddress, label, deterministicPassphrase, \
+                    live = queueValue
                 eighteenByteRipe = False
                 addressVersionNumber = decodeAddress(chanAddress)[1]
                 streamNumber = decodeAddress(chanAddress)[2]
                 numberOfAddressesToMake = 1
                 numberOfNullBytesDemandedOnFrontOfRipeHash = 1
             elif len(queueValue) == 7:
-                command, addressVersionNumber, streamNumber, label, numberOfAddressesToMake, deterministicPassphrase, eighteenByteRipe = queueValue
+                command, addressVersionNumber, streamNumber, label, \
+                    numberOfAddressesToMake, deterministicPassphrase, \
+                    eighteenByteRipe = queueValue
                 try:
-                    numberOfNullBytesDemandedOnFrontOfRipeHash = BMConfigParser().getint(
-                        'bitmessagesettings', 'numberofnullbytesonaddress')
+                    numberOfNullBytesDemandedOnFrontOfRipeHash = \
+                        BMConfigParser().getint(
+                            'bitmessagesettings',
+                            'numberofnullbytesonaddress'
+                        )
                 except:
                     if eighteenByteRipe:
                         numberOfNullBytesDemandedOnFrontOfRipeHash = 2
                     else:
-                        numberOfNullBytesDemandedOnFrontOfRipeHash = 1 # the default
+                        # the default
+                        numberOfNullBytesDemandedOnFrontOfRipeHash = 1
             elif len(queueValue) == 9:
-                command, addressVersionNumber, streamNumber, label, numberOfAddressesToMake, deterministicPassphrase, eighteenByteRipe, nonceTrialsPerByte, payloadLengthExtraBytes = queueValue
+                command, addressVersionNumber, streamNumber, label, \
+                    numberOfAddressesToMake, deterministicPassphrase, \
+                    eighteenByteRipe, nonceTrialsPerByte, \
+                    payloadLengthExtraBytes = queueValue
                 try:
-                    numberOfNullBytesDemandedOnFrontOfRipeHash = BMConfigParser().getint(
-                        'bitmessagesettings', 'numberofnullbytesonaddress')
+                    numberOfNullBytesDemandedOnFrontOfRipeHash = \
+                        BMConfigParser().getint(
+                            'bitmessagesettings',
+                            'numberofnullbytesonaddress'
+                        )
                 except:
                     if eighteenByteRipe:
                         numberOfNullBytesDemandedOnFrontOfRipeHash = 2
                     else:
-                        numberOfNullBytesDemandedOnFrontOfRipeHash = 1 # the default
+                        # the default
+                        numberOfNullBytesDemandedOnFrontOfRipeHash = 1
             elif queueValue[0] == 'stopThread':
                 break
             else:
-                sys.stderr.write(
-                    'Programming error: A structure with the wrong number of values was passed into the addressGeneratorQueue. Here is the queueValue: %s\n' % repr(queueValue))
+                logger.error(
+                    'Programming error: A structure with the wrong number'
+                    ' of values was passed into the addressGeneratorQueue.'
+                    ' Here is the queueValue: %r\n', queueValue)
             if addressVersionNumber < 3 or addressVersionNumber > 4:
-                sys.stderr.write(
-                    'Program error: For some reason the address generator queue has been given a request to create at least one version %s address which it cannot do.\n' % addressVersionNumber)
+                logger.error(
+                    'Program error: For some reason the address generator'
+                    ' queue has been given a request to create at least'
+                    ' one version %s address which it cannot do.\n',
+                    addressVersionNumber)
             if nonceTrialsPerByte == 0:
                 nonceTrialsPerByte = BMConfigParser().getint(
                     'bitmessagesettings', 'defaultnoncetrialsperbyte')
-            if nonceTrialsPerByte < defaults.networkDefaultProofOfWorkNonceTrialsPerByte:
-                nonceTrialsPerByte = defaults.networkDefaultProofOfWorkNonceTrialsPerByte
+            if nonceTrialsPerByte < \
+                    defaults.networkDefaultProofOfWorkNonceTrialsPerByte:
+                nonceTrialsPerByte = \
+                    defaults.networkDefaultProofOfWorkNonceTrialsPerByte
             if payloadLengthExtraBytes == 0:
                 payloadLengthExtraBytes = BMConfigParser().getint(
                     'bitmessagesettings', 'defaultpayloadlengthextrabytes')
-            if payloadLengthExtraBytes < defaults.networkDefaultPayloadLengthExtraBytes:
-                payloadLengthExtraBytes = defaults.networkDefaultPayloadLengthExtraBytes
+            if payloadLengthExtraBytes < \
+                    defaults.networkDefaultPayloadLengthExtraBytes:
+                payloadLengthExtraBytes = \
+                    defaults.networkDefaultPayloadLengthExtraBytes
             if command == 'createRandomAddress':
                 queues.UISignalQueue.put((
-                    'updateStatusBar', tr._translate("MainWindow", "Generating one new address")))
-                # This next section is a little bit strange. We're going to generate keys over and over until we
-                # find one that starts with either \x00 or \x00\x00. Then when we pack them into a Bitmessage address,
-                # we won't store the \x00 or \x00\x00 bytes thus making the
-                # address shorter.
+                    'updateStatusBar',
+                    tr._translate(
+                        "MainWindow", "Generating one new address")
+                ))
+                # This next section is a little bit strange. We're going
+                # to generate keys over and over until we find one
+                # that starts with either \x00 or \x00\x00. Then when
+                # we pack them into a Bitmessage address, we won't store
+                # the \x00 or \x00\x00 bytes thus making the address shorter.
                 startTime = time.time()
                 numberOfAddressesWeHadToMakeBeforeWeFoundOneWithTheCorrectRipePrefix = 0
                 potentialPrivSigningKey = OpenSSL.rand(32)
-                potentialPubSigningKey = highlevelcrypto.pointMult(potentialPrivSigningKey)
+                potentialPubSigningKey = highlevelcrypto.pointMult(
+                    potentialPrivSigningKey)
                 while True:
                     numberOfAddressesWeHadToMakeBeforeWeFoundOneWithTheCorrectRipePrefix += 1
                     potentialPrivEncryptionKey = OpenSSL.rand(32)
@@ -110,15 +140,26 @@ class addressGenerator(threading.Thread, StoppableThread):
                     ripe.update(sha.digest())
                     if ripe.digest()[:numberOfNullBytesDemandedOnFrontOfRipeHash] == '\x00' * numberOfNullBytesDemandedOnFrontOfRipeHash:
                         break
-                logger.info('Generated address with ripe digest: %s' % hexlify(ripe.digest()))
+                logger.info(
+                    'Generated address with ripe digest: %s',
+                    hexlify(ripe.digest()))
                 try:
-                    logger.info('Address generator calculated %s addresses at %s addresses per second before finding one with the correct ripe-prefix.' % (numberOfAddressesWeHadToMakeBeforeWeFoundOneWithTheCorrectRipePrefix, numberOfAddressesWeHadToMakeBeforeWeFoundOneWithTheCorrectRipePrefix / (time.time() - startTime)))
+                    logger.info(
+                        'Address generator calculated %s addresses at %s'
+                        ' addresses per second before finding one with'
+                        ' the correct ripe-prefix.',
+                        numberOfAddressesWeHadToMakeBeforeWeFoundOneWithTheCorrectRipePrefix,
+                        numberOfAddressesWeHadToMakeBeforeWeFoundOneWithTheCorrectRipePrefix
+                        / (time.time() - startTime))
                 except ZeroDivisionError:
-                    # The user must have a pretty fast computer. time.time() - startTime equaled zero.
+                    # The user must have a pretty fast computer.
+                    # time.time() - startTime equaled zero.
                     pass
-                address = encodeAddress(addressVersionNumber, streamNumber, ripe.digest())
+                address = encodeAddress(
+                    addressVersionNumber, streamNumber, ripe.digest())
 
-                # An excellent way for us to store our keys is in Wallet Import Format. Let us convert now.
+                # An excellent way for us to store our keys
+                # is in Wallet Import Format. Let us convert now.
                 # https://en.bitcoin.it/wiki/Wallet_import_format
                 privSigningKey = '\x80' + potentialPrivSigningKey
                 checksum = hashlib.sha256(hashlib.sha256(
@@ -140,18 +181,23 @@ class addressGenerator(threading.Thread, StoppableThread):
                     nonceTrialsPerByte))
                 BMConfigParser().set(address, 'payloadlengthextrabytes', str(
                     payloadLengthExtraBytes))
-                BMConfigParser().set(
-                    address, 'privSigningKey', privSigningKeyWIF)
-                BMConfigParser().set(
-                    address, 'privEncryptionKey', privEncryptionKeyWIF)
+
                 BMConfigParser().save()
 
+                shared.keystore.push_keys(
+                    address, (privEncryptionKeyWIF, privSigningKeyWIF))
+
                 # The API and the join and create Chan functionality
                 # both need information back from the address generator.
                 queues.apiAddressGeneratorReturnQueue.put(address)
 
                 queues.UISignalQueue.put((
-                    'updateStatusBar', tr._translate("MainWindow", "Done generating address. Doing work necessary to broadcast it...")))
+                    'updateStatusBar',
+                    tr._translate(
+                        "MainWindow",
+                        "Done generating address. Doing work necessary"
+                        " to broadcast it...")
+                ))
                 queues.UISignalQueue.put(('writeNewAddressToTable', (
                     label, address, streamNumber)))
                 shared.reloadMyAddressHashes()
@@ -162,31 +208,47 @@ class addressGenerator(threading.Thread, StoppableThread):
                     queues.workerQueue.put((
                         'sendOutOrStoreMyV4Pubkey', address))
 
-            elif command == 'createDeterministicAddresses' or command == 'getDeterministicAddress' or command == 'createChan' or command == 'joinChan':
+            elif command == 'createDeterministicAddresses' \
+                    or command == 'getDeterministicAddress' \
+                    or command == 'createChan' or command == 'joinChan':
                 if len(deterministicPassphrase) == 0:
-                    sys.stderr.write(
-                        'WARNING: You are creating deterministic address(es) using a blank passphrase. Bitmessage will do it but it is rather stupid.')
+                    logger.warning(
+                        'You are creating deterministic'
+                        ' address(es) using a blank passphrase.'
+                        ' Bitmessage will do it but it is rather stupid.')
                 if command == 'createDeterministicAddresses':
                     queues.UISignalQueue.put((
-                                'updateStatusBar', tr._translate("MainWindow","Generating %1 new addresses.").arg(str(numberOfAddressesToMake))))
+                        'updateStatusBar',
+                        tr._translate(
+                            "MainWindow",
+                            "Generating %1 new addresses."
+                        ).arg(str(numberOfAddressesToMake))
+                    ))
                 signingKeyNonce = 0
                 encryptionKeyNonce = 1
-                listOfNewAddressesToSendOutThroughTheAPI = [
-                ]  # We fill out this list no matter what although we only need it if we end up passing the info to the API.
+                # We fill out this list no matter what although we only
+                # need it if we end up passing the info to the API.
+                listOfNewAddressesToSendOutThroughTheAPI = []
 
                 for i in range(numberOfAddressesToMake):
-                    # This next section is a little bit strange. We're going to generate keys over and over until we
-                    # find one that has a RIPEMD hash that starts with either \x00 or \x00\x00. Then when we pack them
-                    # into a Bitmessage address, we won't store the \x00 or
+                    # This next section is a little bit strange. We're
+                    # going to generate keys over and over until we find
+                    # one that has a RIPEMD hash that starts with either
+                    # \x00 or \x00\x00. Then when we pack them into a
+                    # Bitmessage address, we won't store the \x00 or
                     # \x00\x00 bytes thus making the address shorter.
                     startTime = time.time()
                     numberOfAddressesWeHadToMakeBeforeWeFoundOneWithTheCorrectRipePrefix = 0
                     while True:
                         numberOfAddressesWeHadToMakeBeforeWeFoundOneWithTheCorrectRipePrefix += 1
                         potentialPrivSigningKey = hashlib.sha512(
-                            deterministicPassphrase + encodeVarint(signingKeyNonce)).digest()[:32]
+                            deterministicPassphrase +
+                            encodeVarint(signingKeyNonce)
+                        ).digest()[:32]
                         potentialPrivEncryptionKey = hashlib.sha512(
-                            deterministicPassphrase + encodeVarint(encryptionKeyNonce)).digest()[:32]
+                            deterministicPassphrase +
+                            encodeVarint(encryptionKeyNonce)
+                        ).digest()[:32]
                         potentialPubSigningKey = highlevelcrypto.pointMult(
                             potentialPrivSigningKey)
                         potentialPubEncryptionKey = highlevelcrypto.pointMult(
@@ -201,26 +263,39 @@ class addressGenerator(threading.Thread, StoppableThread):
                         if ripe.digest()[:numberOfNullBytesDemandedOnFrontOfRipeHash] == '\x00' * numberOfNullBytesDemandedOnFrontOfRipeHash:
                             break
 
-                    
-                    logger.info('Generated address with ripe digest: %s' % hexlify(ripe.digest()))
+                    logger.info(
+                        'Generated address with ripe digest: %s',
+                        hexlify(ripe.digest()))
                     try:
-                        logger.info('Address generator calculated %s addresses at %s addresses per second before finding one with the correct ripe-prefix.' % (numberOfAddressesWeHadToMakeBeforeWeFoundOneWithTheCorrectRipePrefix, numberOfAddressesWeHadToMakeBeforeWeFoundOneWithTheCorrectRipePrefix / (time.time() - startTime)))
+                        logger.info(
+                            'Address generator calculated %s addresses'
+                            ' at %s addresses per second before finding'
+                            ' one with the correct ripe-prefix.',
+                            numberOfAddressesWeHadToMakeBeforeWeFoundOneWithTheCorrectRipePrefix,
+                            numberOfAddressesWeHadToMakeBeforeWeFoundOneWithTheCorrectRipePrefix /
+                            (time.time() - startTime)
+                        )
                     except ZeroDivisionError:
-                        # The user must have a pretty fast computer. time.time() - startTime equaled zero.
+                        # The user must have a pretty fast computer.
+                        # time.time() - startTime equaled zero.
                         pass
-                    address = encodeAddress(addressVersionNumber, streamNumber, ripe.digest())
+                    address = encodeAddress(
+                        addressVersionNumber, streamNumber, ripe.digest())
 
                     saveAddressToDisk = True
-                    # If we are joining an existing chan, let us check to make sure it matches the provided Bitmessage address
+                    # If we are joining an existing chan, let us check
+                    # to make sure it matches the provided Bitmessage address
                     if command == 'joinChan':
                         if address != chanAddress:
-                            listOfNewAddressesToSendOutThroughTheAPI.append('chan name does not match address')
+                            listOfNewAddressesToSendOutThroughTheAPI.append(
+                                'chan name does not match address')
                             saveAddressToDisk = False
                     if command == 'getDeterministicAddress':
                         saveAddressToDisk = False
 
                     if saveAddressToDisk and live:
-                        # An excellent way for us to store our keys is in Wallet Import Format. Let us convert now.
+                        # An excellent way for us to store our keys is
+                        # in Wallet Import Format. Let us convert now.
                         # https://en.bitcoin.it/wiki/Wallet_import_format
                         privSigningKey = '\x80' + potentialPrivSigningKey
                         checksum = hashlib.sha256(hashlib.sha256(
@@ -235,63 +310,90 @@ class addressGenerator(threading.Thread, StoppableThread):
                         privEncryptionKeyWIF = arithmetic.changebase(
                             privEncryptionKey + checksum, 256, 58)
 
-                        
                         try:
                             BMConfigParser().add_section(address)
                             addressAlreadyExists = False
                         except:
                             addressAlreadyExists = True
-                            
+
                         if addressAlreadyExists:
-                            logger.info('%s already exists. Not adding it again.' % address)
+                            logger.info(
+                                '%s already exists. Not adding it again.',
+                                address
+                            )
                             queues.UISignalQueue.put((
-                                'updateStatusBar', tr._translate("MainWindow","%1 is already in 'Your Identities'. Not adding it again.").arg(address)))
+                                'updateStatusBar',
+                                tr._translate(
+                                    "MainWindow",
+                                    "%1 is already in 'Your Identities'."
+                                    " Not adding it again."
+                                ).arg(address)
+                            ))
                         else:
-                            logger.debug('label: %s' % label)
+                            logger.debug('label: %s', label)
                             BMConfigParser().set(address, 'label', label)
                             BMConfigParser().set(address, 'enabled', 'true')
                             BMConfigParser().set(address, 'decoy', 'false')
-                            if command == 'joinChan' or command == 'createChan':
+                            if command == 'joinChan' \
+                                    or command == 'createChan':
                                 BMConfigParser().set(address, 'chan', 'true')
-                            BMConfigParser().set(address, 'noncetrialsperbyte', str(
-                                nonceTrialsPerByte))
-                            BMConfigParser().set(address, 'payloadlengthextrabytes', str(
-                                payloadLengthExtraBytes))
                             BMConfigParser().set(
-                                address, 'privSigningKey', privSigningKeyWIF)
+                                address, 'noncetrialsperbyte',
+                                str(nonceTrialsPerByte))
                             BMConfigParser().set(
-                                address, 'privEncryptionKey', privEncryptionKeyWIF)
+                                address, 'payloadlengthextrabytes',
+                                str(payloadLengthExtraBytes))
+                            BMConfigParser().set(
+                                address, 'privSigningKey',
+                                privSigningKeyWIF)
+                            BMConfigParser().set(
+                                address, 'privEncryptionKey',
+                                privEncryptionKeyWIF)
                             BMConfigParser().save()
 
-                            queues.UISignalQueue.put(('writeNewAddressToTable', (
-                                label, address, str(streamNumber))))
+                            queues.UISignalQueue.put((
+                                'writeNewAddressToTable',
+                                (label, address, str(streamNumber))
+                            ))
                             listOfNewAddressesToSendOutThroughTheAPI.append(
                                 address)
-                            shared.myECCryptorObjects[ripe.digest()] = highlevelcrypto.makeCryptor(
+                            shared.myECCryptorObjects[ripe.digest()] = \
+                                highlevelcrypto.makeCryptor(
                                 hexlify(potentialPrivEncryptionKey))
                             shared.myAddressesByHash[ripe.digest()] = address
-                            tag = hashlib.sha512(hashlib.sha512(encodeVarint(
-                                addressVersionNumber) + encodeVarint(streamNumber) + ripe.digest()).digest()).digest()[32:]
+                            tag = hashlib.sha512(hashlib.sha512(
+                                encodeVarint(addressVersionNumber) +
+                                encodeVarint(streamNumber) + ripe.digest()
+                            ).digest()).digest()[32:]
                             shared.myAddressesByTag[tag] = address
                             if addressVersionNumber == 3:
+                                # If this is a chan address,
+                                # the worker thread won't send out
+                                # the pubkey over the network.
                                 queues.workerQueue.put((
-                                    'sendOutOrStoreMyV3Pubkey', ripe.digest())) # If this is a chan address,
-                                        # the worker thread won't send out the pubkey over the network.
+                                    'sendOutOrStoreMyV3Pubkey', ripe.digest()))
                             elif addressVersionNumber == 4:
                                 queues.workerQueue.put((
                                     'sendOutOrStoreMyV4Pubkey', address))
                             queues.UISignalQueue.put((
-                                'updateStatusBar', tr._translate("MainWindow", "Done generating address")))
-                    elif saveAddressToDisk and not live and not BMConfigParser().has_section(address):
-                        listOfNewAddressesToSendOutThroughTheAPI.append(address)
+                                'updateStatusBar',
+                                tr._translate(
+                                    "MainWindow", "Done generating address")
+                            ))
+                    elif saveAddressToDisk and not live \
+                            and not BMConfigParser().has_section(address):
+                        listOfNewAddressesToSendOutThroughTheAPI.append(
+                            address)
 
                 # Done generating addresses.
-                if command == 'createDeterministicAddresses' or command == 'joinChan' or command == 'createChan':
+                if command == 'createDeterministicAddresses' \
+                        or command == 'joinChan' or command == 'createChan':
                     queues.apiAddressGeneratorReturnQueue.put(
                         listOfNewAddressesToSendOutThroughTheAPI)
                 elif command == 'getDeterministicAddress':
                     queues.apiAddressGeneratorReturnQueue.put(address)
             else:
                 raise Exception(
-                    "Error in the addressGenerator thread. Thread was given a command it could not understand: " + command)
+                    "Error in the addressGenerator thread. Thread was" +
+                    " given a command it could not understand: " + command)
             queues.addressGeneratorQueue.task_done()
diff --git a/src/class_singleWorker.py b/src/class_singleWorker.py
index 58eb33c..4bde78d 100644
--- a/src/class_singleWorker.py
+++ b/src/class_singleWorker.py
@@ -1,41 +1,47 @@
 from __future__ import division
 
-import threading
-import shared
 import time
-from time import strftime, localtime, gmtime
+import threading
 import random
-from subprocess import call  # used when the API must execute an outside program
-from addresses import *
-import highlevelcrypto
-import proofofwork
-import sys
+import hashlib
+from struct import pack
+# used when the API must execute an outside program
+from subprocess import call
+from binascii import hexlify, unhexlify
+
 import tr
-from bmconfigparser import BMConfigParser
-from debug import logger
-import defaults
-from helper_sql import *
-import helper_inbox
-from helper_generic import addDataPadding
-import helper_msgcoding
-from helper_threading import *
-from inventory import Inventory, PendingUpload
 import l10n
 import protocol
 import queues
 import state
-from binascii import hexlify, unhexlify
+import shared
+import defaults
+import highlevelcrypto
+import proofofwork
+import helper_inbox
+import helper_msgcoding
+from bmconfigparser import BMConfigParser
+from debug import logger
+from inventory import Inventory, PendingUpload
+from addresses import (
+    decodeAddress, encodeVarint, decodeVarint, calculateInventoryHash
+)
+# from helper_generic import addDataPadding
+from helper_threading import StoppableThread
+from helper_sql import sqlQuery, sqlExecute
+
 
 # This thread, of which there is only one, does the heavy lifting:
 # calculating POWs.
 
 def sizeof_fmt(num, suffix='h/s'):
-    for unit in ['','k','M','G','T','P','E','Z']:
+    for unit in ['', 'k', 'M', 'G', 'T', 'P', 'E', 'Z']:
         if abs(num) < 1000.0:
             return "%3.1f%s%s" % (num, unit, suffix)
         num /= 1024.0
     return "%.1f%s%s" % (num, 'Yi', suffix)
 
+
 class singleWorker(threading.Thread, StoppableThread):
 
     def __init__(self):
@@ -57,21 +63,32 @@ class singleWorker(threading.Thread, StoppableThread):
             self.stop.wait(2)
         if state.shutdown > 0:
             return
-        
+
         # Initialize the neededPubkeys dictionary.
         queryreturn = sqlQuery(
-            '''SELECT DISTINCT toaddress FROM sent WHERE (status='awaitingpubkey' AND folder='sent')''')
+            '''SELECT DISTINCT toaddress FROM sent'''
+            ''' WHERE (status='awaitingpubkey' AND folder='sent')''')
         for row in queryreturn:
             toAddress, = row
-            toStatus, toAddressVersionNumber, toStreamNumber, toRipe = decodeAddress(toAddress)
-            if toAddressVersionNumber <= 3 :
+            toStatus, toAddressVersionNumber, toStreamNumber, toRipe = \
+                decodeAddress(toAddress)
+            if toAddressVersionNumber <= 3:
                 state.neededPubkeys[toAddress] = 0
             elif toAddressVersionNumber >= 4:
-                doubleHashOfAddressData = hashlib.sha512(hashlib.sha512(encodeVarint(
-                    toAddressVersionNumber) + encodeVarint(toStreamNumber) + toRipe).digest()).digest()
-                privEncryptionKey = doubleHashOfAddressData[:32] # Note that this is the first half of the sha512 hash.
+                doubleHashOfAddressData = hashlib.sha512(hashlib.sha512(
+                    encodeVarint(toAddressVersionNumber) +
+                    encodeVarint(toStreamNumber) + toRipe
+                ).digest()).digest()
+                # Note that this is the first half of the sha512 hash.
+                privEncryptionKey = doubleHashOfAddressData[:32]
                 tag = doubleHashOfAddressData[32:]
-                state.neededPubkeys[tag] = (toAddress, highlevelcrypto.makeCryptor(hexlify(privEncryptionKey))) # We'll need this for when we receive a pubkey reply: it will be encrypted and we'll need to decrypt it.
+                # We'll need this for when we receive a pubkey reply:
+                # it will be encrypted and we'll need to decrypt it.
+                state.neededPubkeys[tag] = (
+                    toAddress,
+                    highlevelcrypto.makeCryptor(
+                        hexlify(privEncryptionKey))
+                )
 
         # Initialize the shared.ackdataForWhichImWatching data structure
         queryreturn = sqlQuery(
@@ -81,8 +98,9 @@ class singleWorker(threading.Thread, StoppableThread):
             logger.info('Watching for ackdata ' + hexlify(ackdata))
             shared.ackdataForWhichImWatching[ackdata] = 0
 
-        self.stop.wait(
-            10)  # give some time for the GUI to start before we start on existing POW tasks.
+        # give some time for the GUI to start
+        # before we start on existing POW tasks.
+        self.stop.wait(10)
 
         if state.shutdown == 0:
             # just in case there are any pending tasks for msg
@@ -130,68 +148,118 @@ class singleWorker(threading.Thread, StoppableThread):
                 self.busy = 0
                 return
             else:
-                logger.error('Probable programming error: The command sent to the workerThread is weird. It is: %s\n' % command)
+                logger.error(
+                    'Probable programming error: The command sent'
+                    ' to the workerThread is weird. It is: %s\n',
+                    command
+                )
 
             queues.workerQueue.task_done()
         logger.info("Quitting...")
 
-    def doPOWForMyV2Pubkey(self, hash):  # This function also broadcasts out the pubkey message once it is done with the POW
+    def _getKeysForAddress(self, address):
+        privSigningKeyHex = shared.keystore.fetch_key(
+            address, 'privsigningkey')
+        privEncryptionKeyHex = shared.keystore.fetch_key(
+            address, 'privencryptionkey')
+
+        # The \x04 on the beginning of the public keys are not sent.
+        # This way there is only one acceptable way to encode
+        # and send a public key.
+        pubSigningKey = unhexlify(highlevelcrypto.privToPub(
+            privSigningKeyHex))[1:]
+        pubEncryptionKey = unhexlify(highlevelcrypto.privToPub(
+            privEncryptionKeyHex))[1:]
+
+        return privSigningKeyHex, privEncryptionKeyHex, \
+            pubSigningKey, pubEncryptionKey
+
+    def _doPOWDefaults(self, payload, TTL,
+                       log_prefix='',
+                       log_time=False):
+        target = 2 ** 64 / (
+            defaults.networkDefaultProofOfWorkNonceTrialsPerByte * (
+                len(payload) + 8 +
+                defaults.networkDefaultPayloadLengthExtraBytes + ((
+                    TTL * (
+                        len(payload) + 8 +
+                        defaults.networkDefaultPayloadLengthExtraBytes
+                    )) / (2 ** 16))
+            ))
+        initialHash = hashlib.sha512(payload).digest()
+        logger.info(
+            '%s Doing proof of work... TTL set to %s', log_prefix, TTL)
+        if log_time:
+            start_time = time.time()
+        trialValue, nonce = proofofwork.run(target, initialHash)
+        logger.info(
+            '%s Found proof of work %s Nonce: %s',
+            log_prefix, trialValue, nonce
+        )
+        try:
+            delta = time.time() - start_time
+            logger.info(
+                'PoW took %.1f seconds, speed %s.',
+                delta, sizeof_fmt(nonce / delta)
+            )
+        except:  # NameError
+            pass
+        payload = pack('>Q', nonce) + payload
+        # inventoryHash = calculateInventoryHash(payload)
+        return payload
+
+    # This function also broadcasts out the pubkey message
+    # once it is done with the POW
+    def doPOWForMyV2Pubkey(self, hash):
         # Look up my stream number based on my address hash
         """configSections = shared.config.addresses()
         for addressInKeysFile in configSections:
-            if addressInKeysFile <> 'bitmessagesettings':
-                status,addressVersionNumber,streamNumber,hashFromThisParticularAddress = decodeAddress(addressInKeysFile)
+            if addressInKeysFile != 'bitmessagesettings':
+                status, addressVersionNumber, streamNumber, \
+                    hashFromThisParticularAddress = \
+                    decodeAddress(addressInKeysFile)
                 if hash == hashFromThisParticularAddress:
                     myAddress = addressInKeysFile
                     break"""
         myAddress = shared.myAddressesByHash[hash]
         status, addressVersionNumber, streamNumber, hash = decodeAddress(
             myAddress)
-        
-        TTL = int(28 * 24 * 60 * 60 + random.randrange(-300, 300))# 28 days from now plus or minus five minutes
+
+        # 28 days from now plus or minus five minutes
+        TTL = int(28 * 24 * 60 * 60 + random.randrange(-300, 300))
         embeddedTime = int(time.time() + TTL)
         payload = pack('>Q', (embeddedTime))
-        payload += '\x00\x00\x00\x01' # object type: pubkey
+        payload += '\x00\x00\x00\x01'  # object type: pubkey
         payload += encodeVarint(addressVersionNumber)  # Address version number
         payload += encodeVarint(streamNumber)
-        payload += protocol.getBitfield(myAddress)  # bitfield of features supported by me (see the wiki).
+        # bitfield of features supported by me (see the wiki).
+        payload += protocol.getBitfield(myAddress)
 
         try:
-            privSigningKeyBase58 = BMConfigParser().get(
-                myAddress, 'privsigningkey')
-            privEncryptionKeyBase58 = BMConfigParser().get(
-                myAddress, 'privencryptionkey')
+            privSigningKeyHex, privEncryptionKeyHex, \
+                pubSigningKey, pubEncryptionKey = self._getKeysForAddress(
+                    myAddress)
         except Exception as err:
-            logger.error('Error within doPOWForMyV2Pubkey. Could not read the keys from the keys.dat file for a requested address. %s\n' % err)
+            logger.error(
+                'Error within doPOWForMyV2Pubkey. Could not read'
+                ' the keys from the keys.dat file for a requested'
+                ' address. %s\n' % err
+            )
             return
 
-        privSigningKeyHex = hexlify(shared.decodeWalletImportFormat(
-            privSigningKeyBase58))
-        privEncryptionKeyHex = hexlify(shared.decodeWalletImportFormat(
-            privEncryptionKeyBase58))
-        pubSigningKey = unhexlify(highlevelcrypto.privToPub(
-            privSigningKeyHex))
-        pubEncryptionKey = unhexlify(highlevelcrypto.privToPub(
-            privEncryptionKeyHex))
-
-        payload += pubSigningKey[1:]
-        payload += pubEncryptionKey[1:]
+        payload += pubSigningKey + pubEncryptionKey
 
         # Do the POW for this pubkey message
-        target = 2 ** 64 / (defaults.networkDefaultProofOfWorkNonceTrialsPerByte*(len(payload) + 8 + defaults.networkDefaultPayloadLengthExtraBytes + ((TTL*(len(payload)+8+defaults.networkDefaultPayloadLengthExtraBytes))/(2 ** 16))))
-        logger.info('(For pubkey message) Doing proof of work...')
-        initialHash = hashlib.sha512(payload).digest()
-        trialValue, nonce = proofofwork.run(target, initialHash)
-        logger.info('(For pubkey message) Found proof of work ' + str(trialValue), ' Nonce: ', str(nonce))
-        payload = pack('>Q', nonce) + payload
+        payload = self._doPOWDefaults(
+            payload, TTL, log_prefix='(For pubkey message)')
 
         inventoryHash = calculateInventoryHash(payload)
         objectType = 1
         Inventory()[inventoryHash] = (
-            objectType, streamNumber, payload, embeddedTime,'')
+            objectType, streamNumber, payload, embeddedTime, '')
         PendingUpload().add(inventoryHash)
 
-        logger.info('broadcasting inv with hash: ' + hexlify(inventoryHash))
+        logger.info('broadcasting inv with hash: %s', hexlify(inventoryHash))
 
         queues.invQueue.put((streamNumber, inventoryHash))
         queues.UISignalQueue.put(('updateStatusBar', ''))
@@ -200,85 +268,77 @@ class singleWorker(threading.Thread, StoppableThread):
                 myAddress, 'lastpubkeysendtime', str(int(time.time())))
             BMConfigParser().save()
         except:
-            # The user deleted the address out of the keys.dat file before this
-            # finished.
+            # The user deleted the address out of the keys.dat file
+            # before this finished.
             pass
 
     # If this isn't a chan address, this function assembles the pubkey data,
     # does the necessary POW and sends it out. If it *is* a chan then it
     # assembles the pubkey and stores is in the pubkey table so that we can
     # send messages to "ourselves".
-    def sendOutOrStoreMyV3Pubkey(self, hash): 
+    def sendOutOrStoreMyV3Pubkey(self, hash):
         try:
             myAddress = shared.myAddressesByHash[hash]
         except:
-            #The address has been deleted.
+            # The address has been deleted.
             return
         if BMConfigParser().safeGetBoolean(myAddress, 'chan'):
             logger.info('This is a chan address. Not sending pubkey.')
             return
         status, addressVersionNumber, streamNumber, hash = decodeAddress(
             myAddress)
-        
-        TTL = int(28 * 24 * 60 * 60 + random.randrange(-300, 300))# 28 days from now plus or minus five minutes
+
+        # 28 days from now plus or minus five minutes
+        TTL = int(28 * 24 * 60 * 60 + random.randrange(-300, 300))
         embeddedTime = int(time.time() + TTL)
-        signedTimeForProtocolV2 = embeddedTime - TTL
+        # signedTimeForProtocolV2 = embeddedTime - TTL
         """
-        According to the protocol specification, the expiresTime along with the pubkey information is
-        signed. But to be backwards compatible during the upgrade period, we shall sign not the 
-        expiresTime but rather the current time. There must be precisely a 28 day difference
-        between the two. After the upgrade period we'll switch to signing the whole payload with the
+        According to the protocol specification, the expiresTime
+        along with the pubkey information is signed. But to be
+        backwards compatible during the upgrade period, we shall sign
+        not the expiresTime but rather the current time. There must be
+        precisely a 28 day difference between the two. After the upgrade
+        period we'll switch to signing the whole payload with the
         expiresTime time.
         """
         payload = pack('>Q', (embeddedTime))
-        payload += '\x00\x00\x00\x01' # object type: pubkey
+        payload += '\x00\x00\x00\x01'  # object type: pubkey
         payload += encodeVarint(addressVersionNumber)  # Address version number
         payload += encodeVarint(streamNumber)
-        payload += protocol.getBitfield(myAddress)  # bitfield of features supported by me (see the wiki).
+        # bitfield of features supported by me (see the wiki).
+        payload += protocol.getBitfield(myAddress)
 
         try:
-            privSigningKeyBase58 = BMConfigParser().get(
-                myAddress, 'privsigningkey')
-            privEncryptionKeyBase58 = BMConfigParser().get(
-                myAddress, 'privencryptionkey')
+            privSigningKeyHex, privEncryptionKeyHex, \
+                pubSigningKey, pubEncryptionKey = self._getKeysForAddress(
+                    myAddress)
         except Exception as err:
-            logger.error('Error within sendOutOrStoreMyV3Pubkey. Could not read the keys from the keys.dat file for a requested address. %s\n' % err)
-
+            logger.error(
+                'Error within sendOutOrStoreMyV3Pubkey. Could not read'
+                ' the keys from the keys.dat file for a requested'
+                ' address. %s\n' % err
+            )
             return
 
-        privSigningKeyHex = hexlify(shared.decodeWalletImportFormat(
-            privSigningKeyBase58))
-        privEncryptionKeyHex = hexlify(shared.decodeWalletImportFormat(
-            privEncryptionKeyBase58))
-        pubSigningKey = unhexlify(highlevelcrypto.privToPub(
-            privSigningKeyHex))
-        pubEncryptionKey = unhexlify(highlevelcrypto.privToPub(
-            privEncryptionKeyHex))
-
-        payload += pubSigningKey[1:]
-        payload += pubEncryptionKey[1:]
+        payload += pubSigningKey + pubEncryptionKey
 
         payload += encodeVarint(BMConfigParser().getint(
             myAddress, 'noncetrialsperbyte'))
         payload += encodeVarint(BMConfigParser().getint(
             myAddress, 'payloadlengthextrabytes'))
-        
+
         signature = highlevelcrypto.sign(payload, privSigningKeyHex)
         payload += encodeVarint(len(signature))
         payload += signature
 
         # Do the POW for this pubkey message
-        target = 2 ** 64 / (defaults.networkDefaultProofOfWorkNonceTrialsPerByte*(len(payload) + 8 + defaults.networkDefaultPayloadLengthExtraBytes + ((TTL*(len(payload)+8+defaults.networkDefaultPayloadLengthExtraBytes))/(2 ** 16))))
-        logger.info('(For pubkey message) Doing proof of work...')
-        initialHash = hashlib.sha512(payload).digest()
-        trialValue, nonce = proofofwork.run(target, initialHash)
-        logger.info('(For pubkey message) Found proof of work. Nonce: ' + str(nonce))
+        payload = self._doPOWDefaults(
+            payload, TTL, log_prefix='(For pubkey message)')
 
-        payload = pack('>Q', nonce) + payload
         inventoryHash = calculateInventoryHash(payload)
         objectType = 1
         Inventory()[inventoryHash] = (
-            objectType, streamNumber, payload, embeddedTime,'')
+            objectType, streamNumber, payload, embeddedTime, '')
         PendingUpload().add(inventoryHash)
 
         logger.info('broadcasting inv with hash: ' + hexlify(inventoryHash))
@@ -290,85 +350,83 @@ class singleWorker(threading.Thread, StoppableThread):
                 myAddress, 'lastpubkeysendtime', str(int(time.time())))
             BMConfigParser().save()
         except:
-            # The user deleted the address out of the keys.dat file before this
-            # finished.
+            # The user deleted the address out of the keys.dat file
+            # before this finished.
             pass
 
-    # If this isn't a chan address, this function assembles the pubkey data,
-    # does the necessary POW and sends it out. 
+    # If this isn't a chan address, this function assembles
+    # the pubkey data, does the necessary POW and sends it out.
     def sendOutOrStoreMyV4Pubkey(self, myAddress):
         if not BMConfigParser().has_section(myAddress):
-            #The address has been deleted.
+            # The address has been deleted.
             return
         if shared.BMConfigParser().safeGetBoolean(myAddress, 'chan'):
             logger.info('This is a chan address. Not sending pubkey.')
             return
         status, addressVersionNumber, streamNumber, hash = decodeAddress(
             myAddress)
-        
-        TTL = int(28 * 24 * 60 * 60 + random.randrange(-300, 300))# 28 days from now plus or minus five minutes
+
+        # 28 days from now plus or minus five minutes
+        TTL = int(28 * 24 * 60 * 60 + random.randrange(-300, 300))
         embeddedTime = int(time.time() + TTL)
         payload = pack('>Q', (embeddedTime))
-        payload += '\x00\x00\x00\x01' # object type: pubkey
+        payload += '\x00\x00\x00\x01'  # object type: pubkey
         payload += encodeVarint(addressVersionNumber)  # Address version number
         payload += encodeVarint(streamNumber)
         dataToEncrypt = protocol.getBitfield(myAddress)
 
         try:
-            privSigningKeyBase58 = BMConfigParser().get(
-                myAddress, 'privsigningkey')
-            privEncryptionKeyBase58 = BMConfigParser().get(
-                myAddress, 'privencryptionkey')
+            privSigningKeyHex, privEncryptionKeyHex, \
+                pubSigningKey, pubEncryptionKey = self._getKeysForAddress(
+                    myAddress)
         except Exception as err:
-            logger.error('Error within sendOutOrStoreMyV4Pubkey. Could not read the keys from the keys.dat file for a requested address. %s\n' % err)
+            logger.error(
+                'Error within sendOutOrStoreMyV4Pubkey. Could not read'
+                ' the keys from the keys.dat file for a requested'
+                ' address. %s\n' % err
+            )
             return
 
-        privSigningKeyHex = hexlify(shared.decodeWalletImportFormat(
-            privSigningKeyBase58))
-        privEncryptionKeyHex = hexlify(shared.decodeWalletImportFormat(
-            privEncryptionKeyBase58))
-        pubSigningKey = unhexlify(highlevelcrypto.privToPub(
-            privSigningKeyHex))
-        pubEncryptionKey = unhexlify(highlevelcrypto.privToPub(
-            privEncryptionKeyHex))
-        dataToEncrypt += pubSigningKey[1:]
-        dataToEncrypt += pubEncryptionKey[1:]
+        dataToEncrypt += pubSigningKey + pubEncryptionKey
 
         dataToEncrypt += encodeVarint(BMConfigParser().getint(
             myAddress, 'noncetrialsperbyte'))
         dataToEncrypt += encodeVarint(BMConfigParser().getint(
             myAddress, 'payloadlengthextrabytes'))
-        
+
         # When we encrypt, we'll use a hash of the data
-        # contained in an address as a decryption key. This way in order to
-        # read the public keys in a pubkey message, a node must know the address
-        # first. We'll also tag, unencrypted, the pubkey with part of the hash
-        # so that nodes know which pubkey object to try to decrypt when they
-        # want to send a message.
-        doubleHashOfAddressData = hashlib.sha512(hashlib.sha512(encodeVarint(
-            addressVersionNumber) + encodeVarint(streamNumber) + hash).digest()).digest()
-        payload += doubleHashOfAddressData[32:] # the tag
-        signature = highlevelcrypto.sign(payload + dataToEncrypt, privSigningKeyHex)
+        # contained in an address as a decryption key. This way
+        # in order to read the public keys in a pubkey message,
+        # a node must know the address first. We'll also tag,
+        # unencrypted, the pubkey with part of the hash so that nodes
+        # know which pubkey object to try to decrypt
+        # when they want to send a message.
+        doubleHashOfAddressData = hashlib.sha512(hashlib.sha512(
+            encodeVarint(addressVersionNumber) +
+            encodeVarint(streamNumber) + hash
+        ).digest()).digest()
+        payload += doubleHashOfAddressData[32:]  # the tag
+        signature = highlevelcrypto.sign(
+            payload + dataToEncrypt, privSigningKeyHex
+        )
         dataToEncrypt += encodeVarint(len(signature))
         dataToEncrypt += signature
-        
+
         privEncryptionKey = doubleHashOfAddressData[:32]
         pubEncryptionKey = highlevelcrypto.pointMult(privEncryptionKey)
         payload += highlevelcrypto.encrypt(
             dataToEncrypt, hexlify(pubEncryptionKey))
 
         # Do the POW for this pubkey message
-        target = 2 ** 64 / (defaults.networkDefaultProofOfWorkNonceTrialsPerByte*(len(payload) + 8 + defaults.networkDefaultPayloadLengthExtraBytes + ((TTL*(len(payload)+8+defaults.networkDefaultPayloadLengthExtraBytes))/(2 ** 16))))
-        logger.info('(For pubkey message) Doing proof of work...')
-        initialHash = hashlib.sha512(payload).digest()
-        trialValue, nonce = proofofwork.run(target, initialHash)
-        logger.info('(For pubkey message) Found proof of work ' + str(trialValue) + 'Nonce: ' + str(nonce))
+        payload = self._doPOWDefaults(
+            payload, TTL, log_prefix='(For pubkey message)')
 
-        payload = pack('>Q', nonce) + payload
         inventoryHash = calculateInventoryHash(payload)
         objectType = 1
         Inventory()[inventoryHash] = (
-            objectType, streamNumber, payload, embeddedTime, doubleHashOfAddressData[32:])
+            objectType, streamNumber, payload, embeddedTime,
+            doubleHashOfAddressData[32:]
+        )
         PendingUpload().add(inventoryHash)
 
         logger.info('broadcasting inv with hash: ' + hexlify(inventoryHash))
@@ -380,66 +438,80 @@ class singleWorker(threading.Thread, StoppableThread):
                 myAddress, 'lastpubkeysendtime', str(int(time.time())))
             BMConfigParser().save()
         except Exception as err:
-            logger.error('Error: Couldn\'t add the lastpubkeysendtime to the keys.dat file. Error message: %s' % err)
+            logger.error(
+                'Error: Couldn\'t add the lastpubkeysendtime'
+                ' to the keys.dat file. Error message: %s' % err
+            )
 
     def sendBroadcast(self):
         # Reset just in case
         sqlExecute(
-            '''UPDATE sent SET status='broadcastqueued' WHERE status = 'doingbroadcastpow' ''')
+            '''UPDATE sent SET status='broadcastqueued' '''
+            '''WHERE status = 'doingbroadcastpow' ''')
         queryreturn = sqlQuery(
-            '''SELECT fromaddress, subject, message, ackdata, ttl, encodingtype FROM sent WHERE status=? and folder='sent' ''', 'broadcastqueued')
+            '''SELECT fromaddress, subject, message, '''
+            ''' ackdata, ttl, encodingtype FROM sent '''
+            ''' WHERE status=? and folder='sent' ''', 'broadcastqueued')
 
         for row in queryreturn:
             fromaddress, subject, body, ackdata, TTL, encoding = row
-            status, addressVersionNumber, streamNumber, ripe = decodeAddress(
-                fromaddress)
+            status, addressVersionNumber, streamNumber, ripe = \
+                decodeAddress(fromaddress)
             if addressVersionNumber <= 1:
-                logger.error('Error: In the singleWorker thread, the sendBroadcast function doesn\'t understand the address version.\n')
+                logger.error(
+                    'Error: In the singleWorker thread, the '
+                    ' sendBroadcast function doesn\'t understand'
+                    ' the address version.\n')
                 return
             # We need to convert our private keys to public keys in order
             # to include them.
             try:
-                privSigningKeyBase58 = BMConfigParser().get(
-                    fromaddress, 'privsigningkey')
-                privEncryptionKeyBase58 = BMConfigParser().get(
-                    fromaddress, 'privencryptionkey')
+                privSigningKeyHex, privEncryptionKeyHex, \
+                    pubSigningKey, pubEncryptionKey = self._getKeysForAddress(
+                        fromaddress)
             except:
-                queues.UISignalQueue.put(('updateSentItemStatusByAckdata', (
-                    ackdata, tr._translate("MainWindow", "Error! Could not find sender address (your address) in the keys.dat file."))))
+                queues.UISignalQueue.put((
+                    'updateSentItemStatusByAckdata', (
+                        ackdata,
+                        tr._translate(
+                            "MainWindow",
+                            "Error! Could not find sender address"
+                            " (your address) in the keys.dat file."))
+                ))
                 continue
 
             sqlExecute(
-                '''UPDATE sent SET status='doingbroadcastpow' WHERE ackdata=? AND status='broadcastqueued' ''',
+                '''UPDATE sent SET status='doingbroadcastpow' '''
+                ''' WHERE ackdata=? AND status='broadcastqueued' ''',
                 ackdata)
 
-            privSigningKeyHex = hexlify(shared.decodeWalletImportFormat(
-                privSigningKeyBase58))
-            privEncryptionKeyHex = hexlify(shared.decodeWalletImportFormat(
-                privEncryptionKeyBase58))
-
-            pubSigningKey = highlevelcrypto.privToPub(privSigningKeyHex).decode(
-                'hex')  # At this time these pubkeys are 65 bytes long because they include the encoding byte which we won't be sending in the broadcast message.
-            pubEncryptionKey = unhexlify(highlevelcrypto.privToPub(
-                privEncryptionKeyHex))
+            # At this time these pubkeys are 65 bytes long
+            # because they include the encoding byte which we won't
+            # be sending in the broadcast message.
+            # pubSigningKey = \
+            #     highlevelcrypto.privToPub(privSigningKeyHex).decode('hex')
 
             if TTL > 28 * 24 * 60 * 60:
                 TTL = 28 * 24 * 60 * 60
-            if TTL < 60*60:
-                TTL = 60*60
-            TTL = int(TTL + random.randrange(-300, 300))# add some randomness to the TTL
+            if TTL < 60 * 60:
+                TTL = 60 * 60
+            # add some randomness to the TTL
+            TTL = int(TTL + random.randrange(-300, 300))
             embeddedTime = int(time.time() + TTL)
             payload = pack('>Q', embeddedTime)
-            payload += '\x00\x00\x00\x03' # object type: broadcast
+            payload += '\x00\x00\x00\x03'  # object type: broadcast
 
             if addressVersionNumber <= 3:
                 payload += encodeVarint(4)  # broadcast version
             else:
                 payload += encodeVarint(5)  # broadcast version
-            
+
             payload += encodeVarint(streamNumber)
             if addressVersionNumber >= 4:
-                doubleHashOfAddressData = hashlib.sha512(hashlib.sha512(encodeVarint(
-                    addressVersionNumber) + encodeVarint(streamNumber) + ripe).digest()).digest()
+                doubleHashOfAddressData = hashlib.sha512(hashlib.sha512(
+                    encodeVarint(addressVersionNumber) +
+                    encodeVarint(streamNumber) + ripe
+                ).digest()).digest()
                 tag = doubleHashOfAddressData[32:]
                 payload += tag
             else:
@@ -447,31 +519,39 @@ class singleWorker(threading.Thread, StoppableThread):
 
             dataToEncrypt = encodeVarint(addressVersionNumber)
             dataToEncrypt += encodeVarint(streamNumber)
-            dataToEncrypt += protocol.getBitfield(fromaddress)  # behavior bitfield
-            dataToEncrypt += pubSigningKey[1:]
-            dataToEncrypt += pubEncryptionKey[1:]
+            # behavior bitfield
+            dataToEncrypt += protocol.getBitfield(fromaddress)
+            dataToEncrypt += pubSigningKey + pubEncryptionKey
             if addressVersionNumber >= 3:
-                dataToEncrypt += encodeVarint(BMConfigParser().getint(fromaddress,'noncetrialsperbyte'))
-                dataToEncrypt += encodeVarint(BMConfigParser().getint(fromaddress,'payloadlengthextrabytes'))
-            dataToEncrypt += encodeVarint(encoding) # message encoding type
-            encodedMessage = helper_msgcoding.MsgEncode({"subject": subject, "body": body}, encoding)
+                dataToEncrypt += encodeVarint(BMConfigParser().getint(
+                    fromaddress, 'noncetrialsperbyte'))
+                dataToEncrypt += encodeVarint(BMConfigParser().getint(
+                    fromaddress, 'payloadlengthextrabytes'))
+            # message encoding type
+            dataToEncrypt += encodeVarint(encoding)
+            encodedMessage = helper_msgcoding.MsgEncode(
+                {"subject": subject, "body": body}, encoding)
             dataToEncrypt += encodeVarint(encodedMessage.length)
             dataToEncrypt += encodedMessage.data
             dataToSign = payload + dataToEncrypt
-            
+
             signature = highlevelcrypto.sign(
                 dataToSign, privSigningKeyHex)
             dataToEncrypt += encodeVarint(len(signature))
             dataToEncrypt += signature
 
-            # Encrypt the broadcast with the information contained in the broadcaster's address. 
-            # Anyone who knows the address can generate the private encryption key to decrypt 
-            # the broadcast. This provides virtually no privacy; its purpose is to keep 
-            # questionable and illegal content from flowing through the Internet connections 
-            # and being stored on the disk of 3rd parties. 
+            # Encrypt the broadcast with the information
+            # contained in the broadcaster's address.
+            # Anyone who knows the address can generate
+            # the private encryption key to decrypt the broadcast.
+            # This provides virtually no privacy; its purpose is to keep
+            # questionable and illegal content from flowing through the
+            # Internet connections and being stored on the disk of 3rd parties.
             if addressVersionNumber <= 3:
-                privEncryptionKey = hashlib.sha512(encodeVarint(
-                    addressVersionNumber) + encodeVarint(streamNumber) + ripe).digest()[:32]
+                privEncryptionKey = hashlib.sha512(
+                    encodeVarint(addressVersionNumber) +
+                    encodeVarint(streamNumber) + ripe
+                ).digest()[:32]
             else:
                 privEncryptionKey = doubleHashOfAddressData[:32]
 
@@ -479,21 +559,26 @@ class singleWorker(threading.Thread, StoppableThread):
             payload += highlevelcrypto.encrypt(
                 dataToEncrypt, hexlify(pubEncryptionKey))
 
-            target = 2 ** 64 / (defaults.networkDefaultProofOfWorkNonceTrialsPerByte*(len(payload) + 8 + defaults.networkDefaultPayloadLengthExtraBytes + ((TTL*(len(payload)+8+defaults.networkDefaultPayloadLengthExtraBytes))/(2 ** 16))))
-            logger.info('(For broadcast message) Doing proof of work...')
-            queues.UISignalQueue.put(('updateSentItemStatusByAckdata', (
-                ackdata, tr._translate("MainWindow", "Doing work necessary to send broadcast..."))))
-            initialHash = hashlib.sha512(payload).digest()
-            trialValue, nonce = proofofwork.run(target, initialHash)
-            logger.info('(For broadcast message) Found proof of work ' + str(trialValue) + ' Nonce: ' + str(nonce))
-
-            payload = pack('>Q', nonce) + payload
-            
-            # Sanity check. The payload size should never be larger than 256 KiB. There should
-            # be checks elsewhere in the code to not let the user try to send a message this large
-            # until we implement message continuation. 
-            if len(payload) > 2 ** 18: # 256 KiB
-                logger.critical('This broadcast object is too large to send. This should never happen. Object size: %s' % len(payload))
+            queues.UISignalQueue.put((
+                'updateSentItemStatusByAckdata', (
+                    ackdata,
+                    tr._translate(
+                        "MainWindow",
+                        "Doing work necessary to send broadcast..."))
+            ))
+            payload = self._doPOWDefaults(
+                payload, TTL, log_prefix='(For broadcast message)')
+
+            # Sanity check. The payload size should never be larger
+            # than 256 KiB. There should be checks elsewhere in the code
+            # to not let the user try to send a message this large
+            # until we implement message continuation.
+            if len(payload) > 2 ** 18:  # 256 KiB
+                logger.critical(
+                    'This broadcast object is too large to send.'
+                    ' This should never happen. Object size: %s',
+                    len(payload)
+                )
                 continue
 
             inventoryHash = calculateInventoryHash(payload)
@@ -501,168 +586,295 @@ class singleWorker(threading.Thread, StoppableThread):
             Inventory()[inventoryHash] = (
                 objectType, streamNumber, payload, embeddedTime, tag)
             PendingUpload().add(inventoryHash)
-            logger.info('sending inv (within sendBroadcast function) for object: ' + hexlify(inventoryHash))
+            logger.info(
+                'sending inv (within sendBroadcast function)'
+                ' for object: %s',
+                hexlify(inventoryHash)
+            )
             queues.invQueue.put((streamNumber, inventoryHash))
 
-            queues.UISignalQueue.put(('updateSentItemStatusByAckdata', (ackdata, tr._translate("MainWindow", "Broadcast sent on %1").arg(l10n.formatTimestamp()))))
+            queues.UISignalQueue.put((
+                'updateSentItemStatusByAckdata', (
+                    ackdata,
+                    tr._translate(
+                        "MainWindow",
+                        "Broadcast sent on %1"
+                    ).arg(l10n.formatTimestamp()))
+            ))
 
             # Update the status of the message in the 'sent' table to have
             # a 'broadcastsent' status
             sqlExecute(
-                'UPDATE sent SET msgid=?, status=?, lastactiontime=? WHERE ackdata=?',
-                inventoryHash,
-                'broadcastsent',
-                int(time.time()),
-                ackdata)
-        
+                'UPDATE sent SET msgid=?, status=?, lastactiontime=?'
+                ' WHERE ackdata=?',
+                inventoryHash, 'broadcastsent', int(time.time()), ackdata
+            )
 
     def sendMsg(self):
         # Reset just in case
         sqlExecute(
-            '''UPDATE sent SET status='msgqueued' WHERE status IN ('doingpubkeypow', 'doingmsgpow')''')
+            '''UPDATE sent SET status='msgqueued' '''
+            ''' WHERE status IN ('doingpubkeypow', 'doingmsgpow')''')
         queryreturn = sqlQuery(
-            '''SELECT toaddress, fromaddress, subject, message, ackdata, status, ttl, retrynumber, encodingtype FROM sent WHERE (status='msgqueued' or status='forcepow') and folder='sent' ''')
-        for row in queryreturn: # while we have a msg that needs some work
-            toaddress, fromaddress, subject, message, ackdata, status, TTL, retryNumber, encoding = row
-            toStatus, toAddressVersionNumber, toStreamNumber, toRipe = decodeAddress(
-                toaddress)
-            fromStatus, fromAddressVersionNumber, fromStreamNumber, fromRipe = decodeAddress(
-                fromaddress)
-            
-            # We may or may not already have the pubkey for this toAddress. Let's check.
+            '''SELECT toaddress, fromaddress, subject, message, '''
+            ''' ackdata, status, ttl, retrynumber, encodingtype FROM '''
+            ''' sent WHERE (status='msgqueued' or status='forcepow') '''
+            ''' and folder='sent' ''')
+        # while we have a msg that needs some work
+        for row in queryreturn:
+            toaddress, fromaddress, subject, message, \
+                ackdata, status, TTL, retryNumber, encoding = row
+            toStatus, toAddressVersionNumber, toStreamNumber, toRipe = \
+                decodeAddress(toaddress)
+            fromStatus, fromAddressVersionNumber, fromStreamNumber, \
+                fromRipe = decodeAddress(fromaddress)
+
+            # We may or may not already have the pubkey
+            # for this toAddress. Let's check.
             if status == 'forcepow':
-                # if the status of this msg is 'forcepow' then clearly we have the pubkey already
-                # because the user could not have overridden the message about the POW being
-                # too difficult without knowing the required difficulty.
+                # if the status of this msg is 'forcepow'
+                # then clearly we have the pubkey already
+                # because the user could not have overridden the message
+                # about the POW being too difficult without knowing
+                # the required difficulty.
                 pass
             elif status == 'doingmsgpow':
-                # We wouldn't have set the status to doingmsgpow if we didn't already have the pubkey
-                # so let's assume that we have it.
+                # We wouldn't have set the status to doingmsgpow
+                # if we didn't already have the pubkey so let's assume
+                # that we have it.
                 pass
-            # If we are sending a message to ourselves or a chan then we won't need an entry in the pubkeys table; we can calculate the needed pubkey using the private keys in our keys.dat file.
+            # If we are sending a message to ourselves or a chan
+            # then we won't need an entry in the pubkeys table;
+            # we can calculate the needed pubkey using the private keys
+            # in our keys.dat file.
             elif BMConfigParser().has_section(toaddress):
                 sqlExecute(
-                    '''UPDATE sent SET status='doingmsgpow' WHERE toaddress=? AND status='msgqueued' ''',
-                    toaddress)
-                status='doingmsgpow'
+                    '''UPDATE sent SET status='doingmsgpow' '''
+                    ''' WHERE toaddress=? AND status='msgqueued' ''',
+                    toaddress
+                )
+                status = 'doingmsgpow'
             elif status == 'msgqueued':
                 # Let's see if we already have the pubkey in our pubkeys table
                 queryreturn = sqlQuery(
-                    '''SELECT address FROM pubkeys WHERE address=?''', toaddress)
-                if queryreturn != []:  # If we have the needed pubkey in the pubkey table already, 
+                    '''SELECT address FROM pubkeys WHERE address=?''',
+                    toaddress
+                )
+                # If we have the needed pubkey in the pubkey table already,
+                if queryreturn != []:
                     # set the status of this msg to doingmsgpow
                     sqlExecute(
-                        '''UPDATE sent SET status='doingmsgpow' WHERE toaddress=? AND status='msgqueued' ''',
-                        toaddress)
+                        '''UPDATE sent SET status='doingmsgpow' '''
+                        ''' WHERE toaddress=? AND status='msgqueued' ''',
+                        toaddress
+                    )
                     status = 'doingmsgpow'
-                    # mark the pubkey as 'usedpersonally' so that we don't delete it later. If the pubkey version
-                    # is >= 4 then usedpersonally will already be set to yes because we'll only ever have 
+                    # mark the pubkey as 'usedpersonally' so that
+                    # we don't delete it later. If the pubkey version
+                    # is >= 4 then usedpersonally will already be set
+                    # to yes because we'll only ever have
                     # usedpersonally v4 pubkeys in the pubkeys table.
                     sqlExecute(
-                        '''UPDATE pubkeys SET usedpersonally='yes' WHERE address=?''',
-                        toaddress)
-                else:  # We don't have the needed pubkey in the pubkeys table already.
+                        '''UPDATE pubkeys SET usedpersonally='yes' '''
+                        ''' WHERE address=?''',
+                        toaddress
+                    )
+                # We don't have the needed pubkey in the pubkeys table already.
+                else:
                     if toAddressVersionNumber <= 3:
                         toTag = ''
                     else:
-                        toTag = hashlib.sha512(hashlib.sha512(encodeVarint(toAddressVersionNumber)+encodeVarint(toStreamNumber)+toRipe).digest()).digest()[32:]
-                    if toaddress in state.neededPubkeys or toTag in state.neededPubkeys:
+                        toTag = hashlib.sha512(hashlib.sha512(
+                            encodeVarint(toAddressVersionNumber) +
+                            encodeVarint(toStreamNumber) + toRipe
+                        ).digest()).digest()[32:]
+                    if toaddress in state.neededPubkeys or \
+                            toTag in state.neededPubkeys:
                         # We already sent a request for the pubkey
                         sqlExecute(
-                            '''UPDATE sent SET status='awaitingpubkey', sleeptill=? WHERE toaddress=? AND status='msgqueued' ''', 
-                            int(time.time()) + 2.5*24*60*60,
-                            toaddress)
-                        queues.UISignalQueue.put(('updateSentItemStatusByToAddress', (
-                            toaddress, tr._translate("MainWindow",'Encryption key was requested earlier.'))))
-                        continue #on with the next msg on which we can do some work
+                            '''UPDATE sent SET status='awaitingpubkey', '''
+                            ''' sleeptill=? WHERE toaddress=? '''
+                            ''' AND status='msgqueued' ''',
+                            int(time.time()) + 2.5 * 24 * 60 * 60,
+                            toaddress
+                        )
+                        queues.UISignalQueue.put((
+                            'updateSentItemStatusByToAddress', (
+                                toaddress,
+                                tr._translate(
+                                    "MainWindow",
+                                    "Encryption key was requested earlier."))
+                        ))
+                        # on with the next msg on which we can do some work
+                        continue
                     else:
                         # We have not yet sent a request for the pubkey
                         needToRequestPubkey = True
-                        if toAddressVersionNumber >= 4: # If we are trying to send to address version >= 4 then 
-                                                        # the needed pubkey might be encrypted in the inventory.
-                                                        # If we have it we'll need to decrypt it and put it in 
-                                                        # the pubkeys table.
-                            
-                            # The decryptAndCheckPubkeyPayload function expects that the shared.neededPubkeys
-                            # dictionary already contains the toAddress and cryptor object associated with
-                            # the tag for this toAddress.
-                            doubleHashOfToAddressData = hashlib.sha512(hashlib.sha512(encodeVarint(
-                                toAddressVersionNumber) + encodeVarint(toStreamNumber) + toRipe).digest()).digest()
-                            privEncryptionKey = doubleHashOfToAddressData[:32] # The first half of the sha512 hash.
-                            tag = doubleHashOfToAddressData[32:] # The second half of the sha512 hash.
-                            state.neededPubkeys[tag] = (toaddress, highlevelcrypto.makeCryptor(hexlify(privEncryptionKey)))
+                        # If we are trying to send to address
+                        # version >= 4 then the needed pubkey might be
+                        # encrypted in the inventory.
+                        # If we have it we'll need to decrypt it
+                        # and put it in the pubkeys table.
+
+                        # The decryptAndCheckPubkeyPayload function
+                        # expects that the shared.neededPubkeys dictionary
+                        # already contains the toAddress and cryptor
+                        # object associated with the tag for this toAddress.
+                        if toAddressVersionNumber >= 4:
+                            doubleHashOfToAddressData = hashlib.sha512(
+                                hashlib.sha512(encodeVarint(
+                                    toAddressVersionNumber) +
+                                    encodeVarint(toStreamNumber) +
+                                    toRipe
+                                ).digest()
+                            ).digest()
+                            # The first half of the sha512 hash.
+                            privEncryptionKey = doubleHashOfToAddressData[:32]
+                            # The second half of the sha512 hash.
+                            tag = doubleHashOfToAddressData[32:]
+                            state.neededPubkeys[tag] = (
+                                toaddress,
+                                highlevelcrypto.makeCryptor(
+                                    hexlify(privEncryptionKey))
+                            )
 
                             for value in Inventory().by_type_and_tag(1, toTag):
-                                if shared.decryptAndCheckPubkeyPayload(value.payload, toaddress) == 'successful': #if valid, this function also puts it in the pubkeys table.
+                                # if valid, this function also puts it
+                                # in the pubkeys table.
+                                if shared.decryptAndCheckPubkeyPayload(
+                                        value.payload, toaddress
+                                ) == 'successful':
                                     needToRequestPubkey = False
                                     sqlExecute(
-                                        '''UPDATE sent SET status='doingmsgpow', retrynumber=0 WHERE toaddress=? AND (status='msgqueued' or status='awaitingpubkey' or status='doingpubkeypow')''',
+                                        '''UPDATE sent SET '''
+                                        ''' status='doingmsgpow', '''
+                                        ''' retrynumber=0 WHERE '''
+                                        ''' toaddress=? AND '''
+                                        ''' (status='msgqueued' or '''
+                                        ''' status='awaitingpubkey' or '''
+                                        ''' status='doingpubkeypow')''',
                                         toaddress)
                                     del state.neededPubkeys[tag]
                                     break
-                                #else:  # There was something wrong with this pubkey object even
-                                        # though it had the correct tag- almost certainly because
-                                        # of malicious behavior or a badly programmed client. If
-                                        # there are any other pubkeys in our inventory with the correct
-                                        # tag then we'll try to decrypt those.
+                                # else:
+                                # There was something wrong with this
+                                # pubkey object even though it had
+                                # the correct tag- almost certainly
+                                # because of malicious behavior or
+                                # a badly programmed client. If there are
+                                # any other pubkeys in our inventory
+                                # with the correct tag then we'll try
+                                # to decrypt those.
                         if needToRequestPubkey:
                             sqlExecute(
-                                '''UPDATE sent SET status='doingpubkeypow' WHERE toaddress=? AND status='msgqueued' ''',
-                                toaddress)
-                            queues.UISignalQueue.put(('updateSentItemStatusByToAddress', (
-                                toaddress, tr._translate("MainWindow",'Sending a request for the recipient\'s encryption key.'))))
+                                '''UPDATE sent SET '''
+                                ''' status='doingpubkeypow' WHERE '''
+                                ''' toaddress=? AND status='msgqueued' ''',
+                                toaddress
+                            )
+                            queues.UISignalQueue.put((
+                                'updateSentItemStatusByToAddress', (
+                                    toaddress,
+                                    tr._translate(
+                                        "MainWindow",
+                                        "Sending a request for the"
+                                        " recipient\'s encryption key."))
+                            ))
                             self.requestPubKey(toaddress)
-                            continue #on with the next msg on which we can do some work
-            
-            # At this point we know that we have the necessary pubkey in the pubkeys table.
-            
+                            # on with the next msg on which we can do some work
+                            continue
+
+            # At this point we know that we have the necessary pubkey
+            # in the pubkeys table.
+
             TTL *= 2**retryNumber
             if TTL > 28 * 24 * 60 * 60:
                 TTL = 28 * 24 * 60 * 60
-            TTL = int(TTL + random.randrange(-300, 300))# add some randomness to the TTL
+            # add some randomness to the TTL
+            TTL = int(TTL + random.randrange(-300, 300))
             embeddedTime = int(time.time() + TTL)
-            
-            if not BMConfigParser().has_section(toaddress): # if we aren't sending this to ourselves or a chan
+
+            # if we aren't sending this to ourselves or a chan
+            if not BMConfigParser().has_section(toaddress):
                 shared.ackdataForWhichImWatching[ackdata] = 0
-                queues.UISignalQueue.put(('updateSentItemStatusByAckdata', (
-                    ackdata, tr._translate("MainWindow", "Looking up the receiver\'s public key"))))
+                queues.UISignalQueue.put((
+                    'updateSentItemStatusByAckdata', (
+                        ackdata,
+                        tr._translate(
+                            "MainWindow",
+                            "Looking up the receiver\'s public key"))
+                ))
                 logger.info('Sending a message.')
-                logger.debug('First 150 characters of message: ' + repr(message[:150]))
-
-                # Let us fetch the recipient's public key out of our database. If
-                # the required proof of work difficulty is too hard then we'll
-                # abort.
+                logger.debug(
+                    'First 150 characters of message: %s',
+                    repr(message[:150])
+                )
+
+                # Let us fetch the recipient's public key out of
+                # our database. If the required proof of work difficulty
+                # is too hard then we'll abort.
                 queryreturn = sqlQuery(
                     'SELECT transmitdata FROM pubkeys WHERE address=?',
                     toaddress)
                 for row in queryreturn:
                     pubkeyPayload, = row
 
-                # The pubkey message is stored with the following items all appended:
+                # The pubkey message is stored with the following items
+                # all appended:
                 #    -address version
                 #    -stream number
                 #    -behavior bitfield
                 #    -pub signing key
                 #    -pub encryption key
-                #    -nonce trials per byte (if address version is >= 3) 
+                #    -nonce trials per byte (if address version is >= 3)
                 #    -length extra bytes (if address version is >= 3)
 
-                readPosition = 1  # to bypass the address version whose length is definitely 1
+                # to bypass the address version whose length is definitely 1
+                readPosition = 1
                 streamNumber, streamNumberLength = decodeVarint(
                     pubkeyPayload[readPosition:readPosition + 10])
                 readPosition += streamNumberLength
                 behaviorBitfield = pubkeyPayload[readPosition:readPosition + 4]
-                # Mobile users may ask us to include their address's RIPE hash on a message
-                # unencrypted. Before we actually do it the sending human must check a box
+                # Mobile users may ask us to include their address's
+                # RIPE hash on a message unencrypted. Before we actually
+                # do it the sending human must check a box
                 # in the settings menu to allow it.
-                if shared.isBitSetWithinBitfield(behaviorBitfield,30): # if receiver is a mobile device who expects that their address RIPE is included unencrypted on the front of the message..
-                    if not shared.BMConfigParser().safeGetBoolean('bitmessagesettings','willinglysendtomobile'): # if we are Not willing to include the receiver's RIPE hash on the message..
-                        logger.info('The receiver is a mobile user but the sender (you) has not selected that you are willing to send to mobiles. Aborting send.')
-                        queues.UISignalQueue.put(('updateSentItemStatusByAckdata',(ackdata,tr._translate("MainWindow",'Problem: Destination is a mobile device who requests that the destination be included in the message but this is disallowed in your settings.  %1').arg(l10n.formatTimestamp()))))
-                        # if the human changes their setting and then sends another message or restarts their client, this one will send at that time.
+
+                # if receiver is a mobile device who expects that their
+                # address RIPE is included unencrypted on the front of
+                # the message..
+                if shared.isBitSetWithinBitfield(behaviorBitfield, 30):
+                    # if we are Not willing to include the receiver's
+                    # RIPE hash on the message..
+                    if not shared.BMConfigParser().safeGetBoolean(
+                            'bitmessagesettings', 'willinglysendtomobile'
+                    ):
+                        logger.info(
+                            'The receiver is a mobile user but the'
+                            ' sender (you) has not selected that you'
+                            ' are willing to send to mobiles. Aborting'
+                            ' send.'
+                        )
+                        queues.UISignalQueue.put((
+                            'updateSentItemStatusByAckdata', (
+                                ackdata,
+                                tr._translate(
+                                    "MainWindow",
+                                    "Problem: Destination is a mobile"
+                                    " device who requests that the"
+                                    " destination be included in the"
+                                    " message but this is disallowed in"
+                                    " your settings.  %1"
+                                ).arg(l10n.formatTimestamp()))
+                        ))
+                        # if the human changes their setting and then
+                        # sends another message or restarts their client,
+                        # this one will send at that time.
                         continue
                 readPosition += 4  # to bypass the bitfield of behaviors
-                # pubSigningKeyBase256 = pubkeyPayload[readPosition:readPosition+64] # We don't use this key for anything here.
+                # We don't use this key for anything here.
+                # pubSigningKeyBase256 =
+                # pubkeyPayload[readPosition:readPosition+64]
                 readPosition += 64
                 pubEncryptionKeyBase256 = pubkeyPayload[
                     readPosition:readPosition + 64]
@@ -670,92 +882,180 @@ class singleWorker(threading.Thread, StoppableThread):
 
                 # Let us fetch the amount of work required by the recipient.
                 if toAddressVersionNumber == 2:
-                    requiredAverageProofOfWorkNonceTrialsPerByte = defaults.networkDefaultProofOfWorkNonceTrialsPerByte
-                    requiredPayloadLengthExtraBytes = defaults.networkDefaultPayloadLengthExtraBytes
-                    queues.UISignalQueue.put(('updateSentItemStatusByAckdata', (
-                        ackdata, tr._translate("MainWindow", "Doing work necessary to send message.\nThere is no required difficulty for version 2 addresses like this."))))
+                    requiredAverageProofOfWorkNonceTrialsPerByte = \
+                        defaults.networkDefaultProofOfWorkNonceTrialsPerByte
+                    requiredPayloadLengthExtraBytes = \
+                        defaults.networkDefaultPayloadLengthExtraBytes
+                    queues.UISignalQueue.put((
+                        'updateSentItemStatusByAckdata', (
+                            ackdata,
+                            tr._translate(
+                                "MainWindow",
+                                "Doing work necessary to send message.\n"
+                                "There is no required difficulty for"
+                                " version 2 addresses like this."))
+                    ))
                 elif toAddressVersionNumber >= 3:
-                    requiredAverageProofOfWorkNonceTrialsPerByte, varintLength = decodeVarint(
-                        pubkeyPayload[readPosition:readPosition + 10])
+                    requiredAverageProofOfWorkNonceTrialsPerByte, \
+                        varintLength = decodeVarint(
+                            pubkeyPayload[readPosition:readPosition + 10])
                     readPosition += varintLength
-                    requiredPayloadLengthExtraBytes, varintLength = decodeVarint(
-                        pubkeyPayload[readPosition:readPosition + 10])
+                    requiredPayloadLengthExtraBytes, varintLength = \
+                        decodeVarint(
+                            pubkeyPayload[readPosition:readPosition + 10])
                     readPosition += varintLength
-                    if requiredAverageProofOfWorkNonceTrialsPerByte < defaults.networkDefaultProofOfWorkNonceTrialsPerByte:  # We still have to meet a minimum POW difficulty regardless of what they say is allowed in order to get our message to propagate through the network.
-                        requiredAverageProofOfWorkNonceTrialsPerByte = defaults.networkDefaultProofOfWorkNonceTrialsPerByte
-                    if requiredPayloadLengthExtraBytes < defaults.networkDefaultPayloadLengthExtraBytes:
-                        requiredPayloadLengthExtraBytes = defaults.networkDefaultPayloadLengthExtraBytes
-                    logger.debug('Using averageProofOfWorkNonceTrialsPerByte: %s and payloadLengthExtraBytes: %s.' % (requiredAverageProofOfWorkNonceTrialsPerByte, requiredPayloadLengthExtraBytes))
-                    queues.UISignalQueue.put(('updateSentItemStatusByAckdata', (ackdata, tr._translate("MainWindow", "Doing work necessary to send message.\nReceiver\'s required difficulty: %1 and %2").arg(str(float(
-                        requiredAverageProofOfWorkNonceTrialsPerByte) / defaults.networkDefaultProofOfWorkNonceTrialsPerByte)).arg(str(float(requiredPayloadLengthExtraBytes) / defaults.networkDefaultPayloadLengthExtraBytes)))))
+                    # We still have to meet a minimum POW difficulty
+                    # regardless of what they say is allowed in order
+                    # to get our message to propagate through the network.
+                    if requiredAverageProofOfWorkNonceTrialsPerByte < \
+                            defaults.networkDefaultProofOfWorkNonceTrialsPerByte:  
+                        requiredAverageProofOfWorkNonceTrialsPerByte = \
+                            defaults.networkDefaultProofOfWorkNonceTrialsPerByte
+                    if requiredPayloadLengthExtraBytes < \
+                            defaults.networkDefaultPayloadLengthExtraBytes:
+                        requiredPayloadLengthExtraBytes = \
+                            defaults.networkDefaultPayloadLengthExtraBytes
+                    logger.debug(
+                        'Using averageProofOfWorkNonceTrialsPerByte: %s'
+                        ' and payloadLengthExtraBytes: %s.' % (
+                            requiredAverageProofOfWorkNonceTrialsPerByte,
+                            requiredPayloadLengthExtraBytes
+                        ))
+                    queues.UISignalQueue.put((
+                        'updateSentItemStatusByAckdata', (
+                            ackdata,
+                            tr._translate(
+                                "MainWindow",
+                                "Doing work necessary to send message.\n"
+                                "Receiver\'s required difficulty: %1"
+                                " and %2"
+                            ).arg(str(float(
+                                requiredAverageProofOfWorkNonceTrialsPerByte) /
+                                defaults.networkDefaultProofOfWorkNonceTrialsPerByte
+                                )).arg(str(float(
+                                    requiredPayloadLengthExtraBytes) /
+                                    defaults.networkDefaultPayloadLengthExtraBytes
+                                    )))))
                     if status != 'forcepow':
-                        if (requiredAverageProofOfWorkNonceTrialsPerByte > BMConfigParser().getint('bitmessagesettings', 'maxacceptablenoncetrialsperbyte') and BMConfigParser().getint('bitmessagesettings', 'maxacceptablenoncetrialsperbyte') != 0) or (requiredPayloadLengthExtraBytes > BMConfigParser().getint('bitmessagesettings', 'maxacceptablepayloadlengthextrabytes') and BMConfigParser().getint('bitmessagesettings', 'maxacceptablepayloadlengthextrabytes') != 0):
-                            # The demanded difficulty is more than we are willing
-                            # to do.
+                        if (requiredAverageProofOfWorkNonceTrialsPerByte
+                            > BMConfigParser().getint(
+                                'bitmessagesettings',
+                                'maxacceptablenoncetrialsperbyte'
+                            ) and
+                            BMConfigParser().getint(
+                                'bitmessagesettings',
+                                'maxacceptablenoncetrialsperbyte'
+                            ) != 0) or (
+                                requiredPayloadLengthExtraBytes
+                                > BMConfigParser().getint(
+                                    'bitmessagesettings',
+                                    'maxacceptablepayloadlengthextrabytes'
+                                ) and
+                                BMConfigParser().getint(
+                                    'bitmessagesettings',
+                                    'maxacceptablepayloadlengthextrabytes'
+                                ) != 0):
+                            # The demanded difficulty is more than
+                            # we are willing to do.
                             sqlExecute(
-                                '''UPDATE sent SET status='toodifficult' WHERE ackdata=? ''',
+                                '''UPDATE sent SET status='toodifficult' '''
+                                ''' WHERE ackdata=? ''',
                                 ackdata)
-                            queues.UISignalQueue.put(('updateSentItemStatusByAckdata', (ackdata, tr._translate("MainWindow", "Problem: The work demanded by the recipient (%1 and %2) is more difficult than you are willing to do. %3").arg(str(float(requiredAverageProofOfWorkNonceTrialsPerByte) / defaults.networkDefaultProofOfWorkNonceTrialsPerByte)).arg(str(float(
-                                requiredPayloadLengthExtraBytes) / defaults.networkDefaultPayloadLengthExtraBytes)).arg(l10n.formatTimestamp()))))
+                            queues.UISignalQueue.put((
+                                'updateSentItemStatusByAckdata', (
+                                    ackdata,
+                                    tr._translate(
+                                        "MainWindow",
+                                        "Problem: The work demanded by"
+                                        " the recipient (%1 and %2) is"
+                                        " more difficult than you are"
+                                        " willing to do. %3"
+                                    ).arg(str(float(
+                                        requiredAverageProofOfWorkNonceTrialsPerByte)
+                                        / defaults.networkDefaultProofOfWorkNonceTrialsPerByte
+                                        )).arg(str(float(
+                                            requiredPayloadLengthExtraBytes)
+                                            / defaults.networkDefaultPayloadLengthExtraBytes
+                                            )).arg(l10n.formatTimestamp()))
+                            ))
                             continue
-            else: # if we are sending a message to ourselves or a chan..
+            else:  # if we are sending a message to ourselves or a chan..
                 logger.info('Sending a message.')
-                logger.debug('First 150 characters of message: ' + repr(message[:150]))
+                logger.debug(
+                    'First 150 characters of message: %r', message[:150])
                 behaviorBitfield = protocol.getBitfield(fromaddress)
 
                 try:
                     privEncryptionKeyBase58 = BMConfigParser().get(
                         toaddress, 'privencryptionkey')
                 except Exception as err:
-                    queues.UISignalQueue.put(('updateSentItemStatusByAckdata',(ackdata,tr._translate("MainWindow",'Problem: You are trying to send a message to yourself or a chan but your encryption key could not be found in the keys.dat file. Could not encrypt message. %1').arg(l10n.formatTimestamp()))))
-                    logger.error('Error within sendMsg. Could not read the keys from the keys.dat file for our own address. %s\n' % err)
+                    queues.UISignalQueue.put((
+                        'updateSentItemStatusByAckdata', (
+                            ackdata,
+                            tr._translate(
+                                "MainWindow",
+                                "Problem: You are trying to send a"
+                                " message to yourself or a chan but your"
+                                " encryption key could not be found in"
+                                " the keys.dat file. Could not encrypt"
+                                " message. %1"
+                            ).arg(l10n.formatTimestamp()))
+                    ))  # log or show the address maybe?
+                    logger.error(
+                        'Error within sendMsg. Could not read the keys'
+                        ' from the keys.dat file for our own address. %s\n'
+                        % err)
                     continue
                 privEncryptionKeyHex = hexlify(shared.decodeWalletImportFormat(
                     privEncryptionKeyBase58))
                 pubEncryptionKeyBase256 = unhexlify(highlevelcrypto.privToPub(
                     privEncryptionKeyHex))[1:]
-                requiredAverageProofOfWorkNonceTrialsPerByte = defaults.networkDefaultProofOfWorkNonceTrialsPerByte
-                requiredPayloadLengthExtraBytes = defaults.networkDefaultPayloadLengthExtraBytes
-                queues.UISignalQueue.put(('updateSentItemStatusByAckdata', (
-                    ackdata, tr._translate("MainWindow", "Doing work necessary to send message."))))
+                requiredAverageProofOfWorkNonceTrialsPerByte = \
+                    defaults.networkDefaultProofOfWorkNonceTrialsPerByte
+                requiredPayloadLengthExtraBytes = \
+                    defaults.networkDefaultPayloadLengthExtraBytes
+                queues.UISignalQueue.put((
+                    'updateSentItemStatusByAckdata', (
+                        ackdata,
+                        tr._translate(
+                            "MainWindow",
+                            "Doing work necessary to send message."))
+                ))
 
             # Now we can start to assemble our message.
             payload = encodeVarint(fromAddressVersionNumber)
             payload += encodeVarint(fromStreamNumber)
-            payload += protocol.getBitfield(fromaddress)  # Bitfield of features and behaviors that can be expected from me. (See https://bitmessage.org/wiki/Protocol_specification#Pubkey_bitfield_features  )
+            # Bitfield of features and behaviors
+            # that can be expected from me. (See
+            # https://bitmessage.org/wiki/Protocol_specification#Pubkey_bitfield_features)
+            payload += protocol.getBitfield(fromaddress)
 
             # We need to convert our private keys to public keys in order
             # to include them.
             try:
-                privSigningKeyBase58 = BMConfigParser().get(
-                    fromaddress, 'privsigningkey')
-                privEncryptionKeyBase58 = BMConfigParser().get(
-                    fromaddress, 'privencryptionkey')
+                privSigningKeyHex, privEncryptionKeyHex, \
+                    pubSigningKey, pubEncryptionKey = self._getKeysForAddress(
+                        fromaddress)
             except:
-                queues.UISignalQueue.put(('updateSentItemStatusByAckdata', (
-                    ackdata, tr._translate("MainWindow", "Error! Could not find sender address (your address) in the keys.dat file."))))
+                queues.UISignalQueue.put((
+                    'updateSentItemStatusByAckdata', (
+                        ackdata,
+                        tr._translate(
+                            "MainWindow",
+                            "Error! Could not find sender address"
+                            " (your address) in the keys.dat file."))
+                ))
                 continue
 
-            privSigningKeyHex = hexlify(shared.decodeWalletImportFormat(
-                privSigningKeyBase58))
-            privEncryptionKeyHex = hexlify(shared.decodeWalletImportFormat(
-                privEncryptionKeyBase58))
-
-            pubSigningKey = unhexlify(highlevelcrypto.privToPub(
-                privSigningKeyHex))
-            pubEncryptionKey = unhexlify(highlevelcrypto.privToPub(
-                privEncryptionKeyHex))
-
-            payload += pubSigningKey[
-                1:]  # The \x04 on the beginning of the public keys are not sent. This way there is only one acceptable way to encode and send a public key.
-            payload += pubEncryptionKey[1:]
+            payload += pubSigningKey + pubEncryptionKey
 
             if fromAddressVersionNumber >= 3:
                 # If the receiver of our message is in our address book,
                 # subscriptions list, or whitelist then we will allow them to
                 # do the network-minimum proof of work. Let us check to see if
                 # the receiver is in any of those lists.
-                if shared.isAddressInMyAddressBookSubscriptionsListOrWhitelist(toaddress):
+                if shared.isAddressInMyAddressBookSubscriptionsListOrWhitelist(
+                        toaddress):
                     payload += encodeVarint(
                         defaults.networkDefaultProofOfWorkNonceTrialsPerByte)
                     payload += encodeVarint(
@@ -766,58 +1066,114 @@ class singleWorker(threading.Thread, StoppableThread):
                     payload += encodeVarint(BMConfigParser().getint(
                         fromaddress, 'payloadlengthextrabytes'))
 
-            payload += toRipe  # This hash will be checked by the receiver of the message to verify that toRipe belongs to them. This prevents a Surreptitious Forwarding Attack.
-            payload += encodeVarint(encoding) # message encoding type
-            encodedMessage = helper_msgcoding.MsgEncode({"subject": subject, "body": message}, encoding)
+            # This hash will be checked by the receiver of the message
+            # to verify that toRipe belongs to them. This prevents
+            # a Surreptitious Forwarding Attack.
+            payload += toRipe
+            payload += encodeVarint(encoding)  # message encoding type
+            encodedMessage = helper_msgcoding.MsgEncode(
+                {"subject": subject, "body": message}, encoding
+            )
             payload += encodeVarint(encodedMessage.length)
             payload += encodedMessage.data
             if BMConfigParser().has_section(toaddress):
-                logger.info('Not bothering to include ackdata because we are sending to ourselves or a chan.')
+                logger.info(
+                    'Not bothering to include ackdata because we are'
+                    ' sending to ourselves or a chan.'
+                )
+                fullAckPayload = ''
+            elif not protocol.checkBitfield(
+                    behaviorBitfield, protocol.BITFIELD_DOESACK):
+                logger.info(
+                    'Not bothering to include ackdata because'
+                    ' the receiver said that they won\'t relay it anyway.'
+                )
                 fullAckPayload = ''
-            elif not protocol.checkBitfield(behaviorBitfield, protocol.BITFIELD_DOESACK):
-                logger.info('Not bothering to include ackdata because the receiver said that they won\'t relay it anyway.')
-                fullAckPayload = ''                    
             else:
+                # The fullAckPayload is a normal msg protocol message
+                # with the proof of work already completed that the
+                # receiver of this message can easily send out.
                 fullAckPayload = self.generateFullAckMessage(
-                    ackdata, toStreamNumber, TTL)  # The fullAckPayload is a normal msg protocol message with the proof of work already completed that the receiver of this message can easily send out.
+                    ackdata, toStreamNumber, TTL)
             payload += encodeVarint(len(fullAckPayload))
             payload += fullAckPayload
-            dataToSign = pack('>Q', embeddedTime) + '\x00\x00\x00\x02' + encodeVarint(1) + encodeVarint(toStreamNumber) + payload 
+            dataToSign = pack('>Q', embeddedTime) + '\x00\x00\x00\x02' + \
+                encodeVarint(1) + encodeVarint(toStreamNumber) + payload
             signature = highlevelcrypto.sign(dataToSign, privSigningKeyHex)
             payload += encodeVarint(len(signature))
             payload += signature
 
             # We have assembled the data that will be encrypted.
             try:
-                encrypted = highlevelcrypto.encrypt(payload,"04"+hexlify(pubEncryptionKeyBase256))
+                encrypted = highlevelcrypto.encrypt(
+                    payload, "04" + hexlify(pubEncryptionKeyBase256)
+                )
             except:
-                sqlExecute('''UPDATE sent SET status='badkey' WHERE ackdata=?''', ackdata)
-                queues.UISignalQueue.put(('updateSentItemStatusByAckdata',(ackdata,tr._translate("MainWindow",'Problem: The recipient\'s encryption key is no good. Could not encrypt message. %1').arg(l10n.formatTimestamp()))))
+                sqlExecute(
+                    '''UPDATE sent SET status='badkey' WHERE ackdata=?''',
+                    ackdata
+                )
+                queues.UISignalQueue.put((
+                    'updateSentItemStatusByAckdata', (
+                        ackdata,
+                        tr._translate(
+                            "MainWindow",
+                            "Problem: The recipient\'s encryption key is"
+                            " no good. Could not encrypt message. %1"
+                        ).arg(l10n.formatTimestamp()))
+                ))
                 continue
-            
+
             encryptedPayload = pack('>Q', embeddedTime)
-            encryptedPayload += '\x00\x00\x00\x02' # object type: msg
-            encryptedPayload += encodeVarint(1) # msg version
+            encryptedPayload += '\x00\x00\x00\x02'  # object type: msg
+            encryptedPayload += encodeVarint(1)  # msg version
             encryptedPayload += encodeVarint(toStreamNumber) + encrypted
-            target = 2 ** 64 / (requiredAverageProofOfWorkNonceTrialsPerByte*(len(encryptedPayload) + 8 + requiredPayloadLengthExtraBytes + ((TTL*(len(encryptedPayload)+8+requiredPayloadLengthExtraBytes))/(2 ** 16))))
-            logger.info('(For msg message) Doing proof of work. Total required difficulty: %f. Required small message difficulty: %f.', float(requiredAverageProofOfWorkNonceTrialsPerByte) / defaults.networkDefaultProofOfWorkNonceTrialsPerByte, float(requiredPayloadLengthExtraBytes) / defaults.networkDefaultPayloadLengthExtraBytes)
+            target = 2 ** 64 / (
+                requiredAverageProofOfWorkNonceTrialsPerByte * (
+                    len(encryptedPayload) + 8 +
+                    requiredPayloadLengthExtraBytes + ((
+                        TTL * (
+                            len(encryptedPayload) + 8 +
+                            requiredPayloadLengthExtraBytes
+                        )) / (2 ** 16))
+                ))
+            logger.info(
+                '(For msg message) Doing proof of work. Total required'
+                ' difficulty: %f. Required small message difficulty: %f.',
+                float(requiredAverageProofOfWorkNonceTrialsPerByte) /
+                defaults.networkDefaultProofOfWorkNonceTrialsPerByte,
+                float(requiredPayloadLengthExtraBytes) /
+                defaults.networkDefaultPayloadLengthExtraBytes
+            )
 
             powStartTime = time.time()
             initialHash = hashlib.sha512(encryptedPayload).digest()
             trialValue, nonce = proofofwork.run(target, initialHash)
-            logger.info('(For msg message) Found proof of work ' + str(trialValue) + ' Nonce: ' + str(nonce))
+            logger.info(
+                '(For msg message) Found proof of work %s Nonce: %s',
+                trialValue, nonce
+            )
             try:
-                logger.info('PoW took %.1f seconds, speed %s.', time.time() - powStartTime, sizeof_fmt(nonce / (time.time() - powStartTime)))
+                logger.info(
+                    'PoW took %.1f seconds, speed %s.',
+                    time.time() - powStartTime,
+                    sizeof_fmt(nonce / (time.time() - powStartTime))
+                )
             except:
                 pass
 
             encryptedPayload = pack('>Q', nonce) + encryptedPayload
-            
-            # Sanity check. The encryptedPayload size should never be larger than 256 KiB. There should
-            # be checks elsewhere in the code to not let the user try to send a message this large
-            # until we implement message continuation. 
-            if len(encryptedPayload) > 2 ** 18: # 256 KiB
-                logger.critical('This msg object is too large to send. This should never happen. Object size: %s' % len(encryptedPayload))
+
+            # Sanity check. The encryptedPayload size should never be
+            # larger than 256 KiB. There should be checks elsewhere
+            # in the code to not let the user try to send a message
+            # this large until we implement message continuation.
+            if len(encryptedPayload) > 2 ** 18:  # 256 KiB
+                logger.critical(
+                    'This msg object is too large to send. This should'
+                    ' never happen. Object size: %i',
+                    len(encryptedPayload)
+                )
                 continue
 
             inventoryHash = calculateInventoryHash(encryptedPayload)
@@ -825,33 +1181,57 @@ class singleWorker(threading.Thread, StoppableThread):
             Inventory()[inventoryHash] = (
                 objectType, toStreamNumber, encryptedPayload, embeddedTime, '')
             PendingUpload().add(inventoryHash)
-            if BMConfigParser().has_section(toaddress) or not protocol.checkBitfield(behaviorBitfield, protocol.BITFIELD_DOESACK):
-                queues.UISignalQueue.put(('updateSentItemStatusByAckdata', (ackdata, tr._translate("MainWindow", "Message sent. Sent at %1").arg(l10n.formatTimestamp()))))
+            if BMConfigParser().has_section(toaddress) or \
+                not protocol.checkBitfield(
+                    behaviorBitfield, protocol.BITFIELD_DOESACK):
+                queues.UISignalQueue.put((
+                    'updateSentItemStatusByAckdata', (
+                        ackdata,
+                        tr._translate(
+                            "MainWindow",
+                            "Message sent. Sent at %1"
+                        ).arg(l10n.formatTimestamp()))
+                ))
             else:
                 # not sending to a chan or one of my addresses
-                queues.UISignalQueue.put(('updateSentItemStatusByAckdata', (ackdata, tr._translate("MainWindow", "Message sent. Waiting for acknowledgement. Sent on %1").arg(l10n.formatTimestamp()))))
-            logger.info('Broadcasting inv for my msg(within sendmsg function):' + hexlify(inventoryHash))
+                queues.UISignalQueue.put((
+                    'updateSentItemStatusByAckdata', (
+                        ackdata,
+                        tr._translate(
+                            "MainWindow",
+                            "Message sent. Waiting for acknowledgement."
+                            " Sent on %1"
+                        ).arg(l10n.formatTimestamp()))
+                ))
+            logger.info(
+                'Broadcasting inv for my msg(within sendmsg function): %s',
+                hexlify(inventoryHash)
+            )
             queues.invQueue.put((toStreamNumber, inventoryHash))
 
-            # Update the sent message in the sent table with the necessary information.
-            if BMConfigParser().has_section(toaddress) or not protocol.checkBitfield(behaviorBitfield, protocol.BITFIELD_DOESACK):
+            # Update the sent message in the sent table with the
+            # necessary information.
+            if BMConfigParser().has_section(toaddress) or \
+                not protocol.checkBitfield(
+                    behaviorBitfield, protocol.BITFIELD_DOESACK):
                 newStatus = 'msgsentnoackexpected'
             else:
                 newStatus = 'msgsent'
             # wait 10% past expiration
             sleepTill = int(time.time() + TTL * 1.1)
-            sqlExecute('''UPDATE sent SET msgid=?, status=?, retrynumber=?, sleeptill=?, lastactiontime=? WHERE ackdata=?''',
-                       inventoryHash,
-                       newStatus,
-                       retryNumber+1,
-                       sleepTill,
-                       int(time.time()),
-                       ackdata)
-
-            # If we are sending to ourselves or a chan, let's put the message in
-            # our own inbox.
+            sqlExecute(
+                '''UPDATE sent SET msgid=?, status=?, retrynumber=?, '''
+                ''' sleeptill=?, lastactiontime=? WHERE ackdata=?''',
+                inventoryHash, newStatus, retryNumber + 1,
+                sleepTill, int(time.time()), ackdata
+            )
+
+            # If we are sending to ourselves or a chan, let's put
+            # the message in our own inbox.
             if BMConfigParser().has_section(toaddress):
-                sigHash = hashlib.sha512(hashlib.sha512(signature).digest()).digest()[32:] # Used to detect and ignore duplicate messages in our inbox
+                # Used to detect and ignore duplicate messages in our inbox
+                sigHash = hashlib.sha512(hashlib.sha512(
+                    signature).digest()).digest()[32:]
                 t = (inventoryHash, toaddress, fromaddress, subject, int(
                     time.time()), message, 'inbox', encoding, 0, sigHash)
                 helper_inbox.insert(t)
@@ -862,7 +1242,8 @@ class singleWorker(threading.Thread, StoppableThread):
                 # If we are behaving as an API then we might need to run an
                 # outside command to let some program know that a new message
                 # has arrived.
-                if BMConfigParser().safeGetBoolean('bitmessagesettings', 'apienabled'):
+                if BMConfigParser().safeGetBoolean(
+                        'bitmessagesettings', 'apienabled'):
                     try:
                         apiNotifyPath = BMConfigParser().get(
                             'bitmessagesettings', 'apinotifypath')
@@ -875,58 +1256,89 @@ class singleWorker(threading.Thread, StoppableThread):
         toStatus, addressVersionNumber, streamNumber, ripe = decodeAddress(
             toAddress)
         if toStatus != 'success':
-            logger.error('Very abnormal error occurred in requestPubKey. toAddress is: ' + repr(
-                    toAddress) + '. Please report this error to Atheros.')
+            logger.error(
+                'Very abnormal error occurred in requestPubKey.'
+                ' toAddress is: %r. Please report this error to Atheros.',
+                toAddress
+            )
             return
-        
+
         queryReturn = sqlQuery(
-            '''SELECT retrynumber FROM sent WHERE toaddress=? AND (status='doingpubkeypow' OR status='awaitingpubkey') LIMIT 1''', 
-            toAddress)
+            '''SELECT retrynumber FROM sent WHERE toaddress=? '''
+            ''' AND (status='doingpubkeypow' OR status='awaitingpubkey') '''
+            ''' LIMIT 1''',
+            toAddress
+        )
         if len(queryReturn) == 0:
-            logger.critical("BUG: Why are we requesting the pubkey for %s if there are no messages in the sent folder to that address?" % toAddress)
+            logger.critical(
+                'BUG: Why are we requesting the pubkey for %s'
+                ' if there are no messages in the sent folder'
+                ' to that address?', toAddress
+            )
             return
         retryNumber = queryReturn[0][0]
 
         if addressVersionNumber <= 3:
             state.neededPubkeys[toAddress] = 0
         elif addressVersionNumber >= 4:
-            # If the user just clicked 'send' then the tag (and other information) will already
-            # be in the neededPubkeys dictionary. But if we are recovering from a restart
-            # of the client then we have to put it in now. 
-            privEncryptionKey = hashlib.sha512(hashlib.sha512(encodeVarint(addressVersionNumber)+encodeVarint(streamNumber)+ripe).digest()).digest()[:32] # Note that this is the first half of the sha512 hash.
-            tag = hashlib.sha512(hashlib.sha512(encodeVarint(addressVersionNumber)+encodeVarint(streamNumber)+ripe).digest()).digest()[32:] # Note that this is the second half of the sha512 hash.
+            # If the user just clicked 'send' then the tag
+            # (and other information) will already be in the
+            # neededPubkeys dictionary. But if we are recovering
+            # from a restart of the client then we have to put it in now.
+
+            # Note that this is the first half of the sha512 hash.
+            privEncryptionKey = hashlib.sha512(hashlib.sha512(
+                encodeVarint(addressVersionNumber) +
+                encodeVarint(streamNumber) + ripe
+            ).digest()).digest()[:32]
+            # Note that this is the second half of the sha512 hash.
+            tag = hashlib.sha512(hashlib.sha512(
+                encodeVarint(addressVersionNumber) +
+                encodeVarint(streamNumber) + ripe
+            ).digest()).digest()[32:]
             if tag not in state.neededPubkeys:
-                state.neededPubkeys[tag] = (toAddress, highlevelcrypto.makeCryptor(hexlify(privEncryptionKey))) # We'll need this for when we receive a pubkey reply: it will be encrypted and we'll need to decrypt it.
-        
-        TTL = 2.5*24*60*60 # 2.5 days. This was chosen fairly arbitrarily. 
-        TTL *= 2**retryNumber
-        if TTL > 28*24*60*60:
-            TTL = 28*24*60*60
-        TTL = TTL + random.randrange(-300, 300) # add some randomness to the TTL
+                # We'll need this for when we receive a pubkey reply:
+                # it will be encrypted and we'll need to decrypt it.
+                state.neededPubkeys[tag] = (
+                    toAddress,
+                    highlevelcrypto.makeCryptor(hexlify(privEncryptionKey))
+                )
+
+        # 2.5 days. This was chosen fairly arbitrarily.
+        TTL = 2.5 * 24 * 60 * 60
+        TTL *= 2 ** retryNumber
+        if TTL > 28 * 24 * 60 * 60:
+            TTL = 28 * 24 * 60 * 60
+        # add some randomness to the TTL
+        TTL = TTL + random.randrange(-300, 300)
         embeddedTime = int(time.time() + TTL)
         payload = pack('>Q', embeddedTime)
-        payload += '\x00\x00\x00\x00' # object type: getpubkey
+        payload += '\x00\x00\x00\x00'  # object type: getpubkey
         payload += encodeVarint(addressVersionNumber)
         payload += encodeVarint(streamNumber)
         if addressVersionNumber <= 3:
             payload += ripe
-            logger.info('making request for pubkey with ripe: %s', hexlify(ripe))
+            logger.info(
+                'making request for pubkey with ripe: %s', hexlify(ripe))
         else:
             payload += tag
-            logger.info('making request for v4 pubkey with tag: %s', hexlify(tag))
+            logger.info(
+                'making request for v4 pubkey with tag: %s', hexlify(tag))
 
         # print 'trial value', trialValue
-        statusbar = 'Doing the computations necessary to request the recipient\'s public key.'
+        statusbar = 'Doing the computations necessary to request' +\
+            ' the recipient\'s public key.'
         queues.UISignalQueue.put(('updateStatusBar', statusbar))
-        queues.UISignalQueue.put(('updateSentItemStatusByToAddress', (
-            toAddress, tr._translate("MainWindow",'Doing work necessary to request encryption key.'))))
-        
-        target = 2 ** 64 / (defaults.networkDefaultProofOfWorkNonceTrialsPerByte*(len(payload) + 8 + defaults.networkDefaultPayloadLengthExtraBytes + ((TTL*(len(payload)+8+defaults.networkDefaultPayloadLengthExtraBytes))/(2 ** 16))))
-        initialHash = hashlib.sha512(payload).digest()
-        trialValue, nonce = proofofwork.run(target, initialHash)
-        logger.info('Found proof of work ' + str(trialValue) + ' Nonce: ' + str(nonce))
+        queues.UISignalQueue.put((
+            'updateSentItemStatusByToAddress', (
+                toAddress,
+                tr._translate(
+                    "MainWindow",
+                    "Doing work necessary to request encryption key."))
+        ))
+
+        payload = self._doPOWDefaults(payload, TTL)
 
-        payload = pack('>Q', nonce) + payload
         inventoryHash = calculateInventoryHash(payload)
         objectType = 1
         Inventory()[inventoryHash] = (
@@ -934,55 +1346,58 @@ class singleWorker(threading.Thread, StoppableThread):
         PendingUpload().add(inventoryHash)
         logger.info('sending inv (for the getpubkey message)')
         queues.invQueue.put((streamNumber, inventoryHash))
-        
+
         # wait 10% past expiration
         sleeptill = int(time.time() + TTL * 1.1)
         sqlExecute(
-            '''UPDATE sent SET lastactiontime=?, status='awaitingpubkey', retrynumber=?, sleeptill=? WHERE toaddress=? AND (status='doingpubkeypow' OR status='awaitingpubkey') ''',
-            int(time.time()),
-            retryNumber+1,
-            sleeptill,
-            toAddress)
+            '''UPDATE sent SET lastactiontime=?, '''
+            ''' status='awaitingpubkey', retrynumber=?, sleeptill=? '''
+            ''' WHERE toaddress=? AND (status='doingpubkeypow' OR '''
+            ''' status='awaitingpubkey') ''',
+            int(time.time()), retryNumber + 1, sleeptill, toAddress)
 
         queues.UISignalQueue.put((
-            'updateStatusBar', tr._translate("MainWindow",'Broadcasting the public key request. This program will auto-retry if they are offline.')))
-        queues.UISignalQueue.put(('updateSentItemStatusByToAddress', (toAddress, tr._translate("MainWindow",'Sending public key request. Waiting for reply. Requested at %1').arg(l10n.formatTimestamp()))))
+            'updateStatusBar',
+            tr._translate(
+                "MainWindow",
+                "Broadcasting the public key request. This program will"
+                " auto-retry if they are offline.")
+        ))
+        queues.UISignalQueue.put((
+            'updateSentItemStatusByToAddress', (
+                toAddress,
+                tr._translate(
+                    "MainWindow",
+                    "Sending public key request. Waiting for reply."
+                    " Requested at %1"
+                ).arg(l10n.formatTimestamp()))
+        ))
 
     def generateFullAckMessage(self, ackdata, toStreamNumber, TTL):
-        
         # It might be perfectly fine to just use the same TTL for
         # the ackdata that we use for the message. But I would rather
-        # it be more difficult for attackers to associate ackData with 
+        # it be more difficult for attackers to associate ackData with
         # the associated msg object. However, users would want the TTL
         # of the acknowledgement to be about the same as they set
-        # for the message itself. So let's set the TTL of the 
-        # acknowledgement to be in one of three 'buckets': 1 hour, 7 
-        # days, or 28 days, whichever is relatively close to what the 
+        # for the message itself. So let's set the TTL of the
+        # acknowledgement to be in one of three 'buckets': 1 hour, 7
+        # days, or 28 days, whichever is relatively close to what the
         # user specified.
-        if TTL < 24*60*60: # 1 day
-            TTL = 24*60*60 # 1 day
-        elif TTL < 7*24*60*60: # 1 week
-            TTL = 7*24*60*60 # 1 week
+        if TTL < 24 * 60 * 60:  # 1 day
+            TTL = 24 * 60 * 60  # 1 day
+        elif TTL < 7 * 24 * 60 * 60:  # 1 week
+            TTL = 7 * 24 * 60 * 60  # 1 week
         else:
-            TTL = 28*24*60*60 # 4 weeks
-        TTL = int(TTL + random.randrange(-300, 300)) # Add some randomness to the TTL
+            TTL = 28 * 24 * 60 * 60  # 4 weeks
+        # Add some randomness to the TTL
+        TTL = int(TTL + random.randrange(-300, 300))
         embeddedTime = int(time.time() + TTL)
         payload = pack('>Q', (embeddedTime))
-        payload += '\x00\x00\x00\x02' # object type: msg
-        payload += encodeVarint(1) # msg version
+        payload += '\x00\x00\x00\x02'  # object type: msg
+        payload += encodeVarint(1)  # msg version
         payload += encodeVarint(toStreamNumber) + ackdata
-        
-        target = 2 ** 64 / (defaults.networkDefaultProofOfWorkNonceTrialsPerByte*(len(payload) + 8 + defaults.networkDefaultPayloadLengthExtraBytes + ((TTL*(len(payload)+8+defaults.networkDefaultPayloadLengthExtraBytes))/(2 ** 16))))
-        logger.info('(For ack message) Doing proof of work. TTL set to ' + str(TTL))
 
-        powStartTime = time.time()
-        initialHash = hashlib.sha512(payload).digest()
-        trialValue, nonce = proofofwork.run(target, initialHash)
-        logger.info('(For ack message) Found proof of work ' + str(trialValue) + ' Nonce: ' + str(nonce))
-        try:
-            logger.info('PoW took %.1f seconds, speed %s.', time.time() - powStartTime, sizeof_fmt(nonce / (time.time() - powStartTime)))
-        except:
-            pass
+        payload = self._doPOWDefaults(
+            payload, TTL, log_prefix='(For ack message)', log_time=True)
 
-        payload = pack('>Q', nonce) + payload
         return protocol.CreatePacket('object', payload)
diff --git a/src/plugins/keystore_gnomekeyring.py b/src/plugins/keystore_gnomekeyring.py
new file mode 100644
index 0000000..71301f1
--- /dev/null
+++ b/src/plugins/keystore_gnomekeyring.py
@@ -0,0 +1,72 @@
+# -*- coding: utf-8 -*-
+
+import gnomekeyring
+
+
+class GnomeKeystore(object):
+
+    def __init__(self, parent):
+        self.keyring = gnomekeyring.get_default_keyring_sync() or 'login'
+        self.parent = parent
+        try:
+            gnomekeyring.create_sync(self.keyring, None)
+        except gnomekeyring.AlreadyExistsError:
+            pass
+
+    def fetch(self, address, key_type):
+        try:
+            keys = gnomekeyring.find_items_sync(
+                gnomekeyring.ITEM_NETWORK_PASSWORD,
+                {'protocol': 'bitmessage',
+                 'address': address}
+            )[0].secret
+        except gnomekeyring.Error:
+            return
+
+        return keys.split(':')[
+            0 if key_type == 'privencryptionkey' else 1]
+
+    def push(self, address, keys):
+        update = self.fetch(address, 'privencryptionkey') is not None
+        try:
+            gnomekeyring.item_create_sync(
+                self.keyring,
+                gnomekeyring.ITEM_NETWORK_PASSWORD,
+                address,
+                {'protocol': 'bitmessage',
+                 'address': address},
+                ':'.join(keys), update
+            )
+        except (gnomekeyring.DeniedError, gnomekeyring.CancelledError):
+            pass
+
+    def _fetch_password(self):
+        try:
+            items = gnomekeyring.find_items_sync(
+                gnomekeyring.ITEM_GENERIC_SECRET,
+                {'pybitmessage': 1}
+            )
+            return items[0].secret
+        except gnomekeyring.Error:
+            pass
+
+    def _push_password(self, password):
+        update = self._fetch_password() is not None
+        try:
+            gnomekeyring.item_create_sync(
+                self.keyring,
+                gnomekeyring.ITEM_GENERIC_SECRET,
+                'PyBitmessage master password',
+                {'pybitmessage': 1}, password, update
+            )
+        except (gnomekeyring.DeniedError, gnomekeyring.CancelledError):
+            pass
+
+    def decrypt(self, data):
+        print('decrypt %r' % data)
+        return self.parent._decrypt_AES_CFB(data, self._fetch_password())
+
+    def encrypt(self, data):
+        return self.parent._encrypt_AES_CFB(data, self._fetch_password())
+
+connect_plugin = GnomeKeystore
diff --git a/src/shared.py b/src/shared.py
index 34597c7..5a3876d 100644
--- a/src/shared.py
+++ b/src/shared.py
@@ -1,105 +1,227 @@
 ﻿from __future__ import division
 
-verbose = 1
-maximumAgeOfAnObjectThatIAmWillingToAccept = 216000  # This is obsolete with the change to protocol v3 but the singleCleaner thread still hasn't been updated so we need this a little longer.
-lengthOfTimeToHoldOnToAllPubkeys = 2419200  # Equals 4 weeks. You could make this longer if you want but making it shorter would not be advisable because there is a very small possibility that it could keep you from obtaining a needed pubkey for a period of time.
-maximumAgeOfNodesThatIAdvertiseToOthers = 10800  # Equals three hours
-useVeryEasyProofOfWorkForTesting = False  # If you set this to True while on the normal network, you won't be able to send or sometimes receive messages.
-
-
 # Libraries.
 import os
 import sys
 import stat
-import threading
 import time
+import threading
 import traceback
-from binascii import hexlify
+import hashlib
+import subprocess
+import ConfigParser
+from struct import unpack
+from binascii import hexlify, unhexlify
+from pyelliptic import arithmetic, Cipher
 
 # Project imports.
-from addresses import *
-from bmconfigparser import BMConfigParser
+import protocol
+import state
 import highlevelcrypto
-#import helper_startup
-from helper_sql import *
+from bmconfigparser import BMConfigParser
+from debug import logger
+from addresses import (
+    decodeAddress, encodeVarint, decodeVarint, varintDecodeError,
+    calculateInventoryHash
+)
+from helper_sql import sqlQuery, sqlExecute
 from inventory import Inventory
 from queues import objectProcessorQueue
-import protocol
-import state
+
+try:
+    from plugins.plugin import get_plugin
+except ImportError:
+    get_plugin = False
+
+
+verbose = 1
+# This is obsolete with the change to protocol v3
+# but the singleCleaner thread still hasn't been updated
+# so we need this a little longer.
+maximumAgeOfAnObjectThatIAmWillingToAccept = 216000
+# Equals 4 weeks. You could make this longer if you want
+# but making it shorter would not be advisable because
+# there is a very small possibility that it could keep you
+# from obtaining a needed pubkey for a period of time.
+lengthOfTimeToHoldOnToAllPubkeys = 2419200
+maximumAgeOfNodesThatIAdvertiseToOthers = 10800  # Equals three hours
+# If you set this to True while on the normal network,
+# you won't be able to send or sometimes receive messages.
+useVeryEasyProofOfWorkForTesting = False
 
 
 myECCryptorObjects = {}
 MyECSubscriptionCryptorObjects = {}
-myAddressesByHash = {} #The key in this dictionary is the RIPE hash which is encoded in an address and value is the address itself.
-myAddressesByTag = {} # The key in this dictionary is the tag generated from the address.
+# The key in this dictionary is the RIPE hash which is encoded
+# in an address and value is the address itself.
+myAddressesByHash = {}
+# The key in this dictionary is the tag generated from the address.
+myAddressesByTag = {}
 broadcastSendersForWhichImWatching = {}
 printLock = threading.Lock()
 statusIconColor = 'red'
-connectedHostsList = {} #List of hosts to which we are connected. Used to guarantee that the outgoingSynSender threads won't connect to the same remote node twice.
-thisapp = None # singleton lock instance
+# List of hosts to which we are connected. Used to guarantee
+# that the outgoingSynSender threads won't connect to the same
+# remote node twice.
+connectedHostsList = {}
+thisapp = None  # singleton lock instance
 alreadyAttemptedConnectionsList = {
 }  # This is a list of nodes to which we have already attempted a connection
 alreadyAttemptedConnectionsListLock = threading.Lock()
-alreadyAttemptedConnectionsListResetTime = int(
-    time.time())  # used to clear out the alreadyAttemptedConnectionsList periodically so that we will retry connecting to hosts to which we have already tried to connect.
-successfullyDecryptMessageTimings = [
-    ]  # A list of the amounts of time it took to successfully decrypt msg messages
+# used to clear out the alreadyAttemptedConnectionsList periodically
+# so that we will retry connecting to hosts to which we have already
+# tried to connect.
+alreadyAttemptedConnectionsListResetTime = int(time.time())
+# A list of the amounts of time it took to successfully decrypt msg messages
+successfullyDecryptMessageTimings = []
 ackdataForWhichImWatching = {}
-clientHasReceivedIncomingConnections = False #used by API command clientStatus
+# used by API command clientStatus
+clientHasReceivedIncomingConnections = False
 numberOfMessagesProcessed = 0
 numberOfBroadcastsProcessed = 0
 numberOfPubkeysProcessed = 0
 daemon = False
-needToWriteKnownNodesToDisk = False # If True, the singleCleaner will write it to disk eventually.
+# If True, the singleCleaner will write it to disk eventually.
+needToWriteKnownNodesToDisk = False
 maximumLengthOfTimeToBotherResendingMessages = 0
 timeOffsetWrongCount = 0
 
+
 def isAddressInMyAddressBook(address):
     queryreturn = sqlQuery(
         '''select address from addressbook where address=?''',
         address)
     return queryreturn != []
 
-#At this point we should really just have a isAddressInMy(book, address)...
+
+# At this point we should really just have a isAddressInMy(book, address)...
 def isAddressInMySubscriptionsList(address):
     queryreturn = sqlQuery(
         '''select * from subscriptions where address=?''',
         str(address))
     return queryreturn != []
 
+
 def isAddressInMyAddressBookSubscriptionsListOrWhitelist(address):
     if isAddressInMyAddressBook(address):
         return True
 
-    queryreturn = sqlQuery('''SELECT address FROM whitelist where address=? and enabled = '1' ''', address)
-    if queryreturn <> []:
+    queryreturn = sqlQuery(
+        '''SELECT address FROM whitelist where address=?'''
+        ''' and enabled = '1' ''',
+        address)
+    if queryreturn != []:
         return True
 
     queryreturn = sqlQuery(
-        '''select address from subscriptions where address=? and enabled = '1' ''',
+        '''select address from subscriptions where address=?'''
+        ''' and enabled = '1' ''',
         address)
-    if queryreturn <> []:
+    if queryreturn != []:
         return True
     return False
 
+
 def decodeWalletImportFormat(WIFstring):
-    fullString = arithmetic.changebase(WIFstring,58,256)
+    fullString = arithmetic.changebase(WIFstring, 58, 256)
     privkey = fullString[:-4]
-    if fullString[-4:] != hashlib.sha256(hashlib.sha256(privkey).digest()).digest()[:4]:
-        logger.critical('Major problem! When trying to decode one of your private keys, the checksum '
-                     'failed. Here are the first 6 characters of the PRIVATE key: %s' % str(WIFstring)[:6])
+    if fullString[-4:] != \
+       hashlib.sha256(hashlib.sha256(privkey).digest()).digest()[:4]:
+        logger.critical(
+            'Major problem! When trying to decode one of your'
+            ' private keys, the checksum failed. Here are the first'
+            ' 6 characters of the PRIVATE key: %s',
+            str(WIFstring)[:6]
+        )
         os._exit(0)
-        return ""
-    else:
-        #checksum passed
-        if privkey[0] == '\x80':
-            return privkey[1:]
-        else:
-            logger.critical('Major problem! When trying to decode one of your private keys, the '
-                         'checksum passed but the key doesn\'t begin with hex 80. Here is the '
-                         'PRIVATE key: %s' % str(WIFstring))
-            os._exit(0)
-            return ""
+        # return ""
+    elif privkey[0] == '\x80':  # checksum passed
+        return privkey[1:]
+
+    logger.critical(
+        'Major problem! When trying to decode one of your  private keys,'
+        ' the checksum passed but the key doesn\'t begin with hex 80.'
+        ' Here is the PRIVATE key: %s', WIFstring
+    )
+    os._exit(0)
+
+
+class Keystore(object):
+    """
+        Class implementing common key storage workflow
+    """
+    def __init__(self):
+        self.config = BMConfigParser()
+        keysencrypted = self.config.getboolean(
+            'bitmessagesettings', 'keysencrypted')
+
+        def noop(key):
+            return key
+
+        self.fetch = self._get_key
+        self.push = self._set_keys
+        self.encrypt = self.decrypt = noop
+
+        try:
+            content, plugin = self.config.get(
+                'bitmessagesettings', 'keystore').split(':')
+            plugin = get_plugin('keystore', name=plugin)(self)
+        except (ConfigParser.NoOptionError, ValueError, TypeError):
+            plugin = None
+
+        if not plugin:
+            if keysencrypted:
+                logger.warning(
+                    'Key encryption plugin not found or unimplimented!')
+            return
+
+        try:
+            if content == 'password' and keysencrypted:
+                self.decrypt = plugin.decrypt
+                self.encrypt = plugin.encrypt
+            elif content == 'keys':
+                self.fetch = plugin.fetch
+                self.push = plugin.push
+        except AttributeError:
+            pass
+
+    def fetch_key(self, address, key_type='privencryptionkey'):
+        """Fetch address key of type key_type from keystore"""
+        try:
+            return hexlify(decodeWalletImportFormat(
+                self.decrypt(self.fetch(address, key_type))
+            ))
+        except TypeError:
+            pass  # handle in reloadMyAddressHashes etc
+
+    def push_keys(self, address, keys):
+        """Push the address keys in WIF into keystore"""
+        self.push(address, [self.encrypt(key) for key in keys])
+
+    def _get_key(self, address, key_type='privencryptionkey'):
+        return self.config.get(address, key_type)
+
+    def _set_keys(self, address, keys):
+        for key, key_type in zip(
+                keys, ('privencryptionkey', 'privsigningkey')):
+            self.config.set(address, key_type, key)
+        self.config.save()
+
+    # simmetric encryption from pyelliptic example:
+    # https://github.com/yann2192/pyelliptic
+    def _encrypt_AES_CFB(self, data, password):
+        nonce = Cipher.gen_IV('aes-256-cfb')
+        ctx = Cipher(password, nonce, 1, ciphername='aes-256-cfb')
+        encrypted = ctx.update(data)
+        encrypted += ctx.final()
+        return ':'.join(hexlify(i) for i in (encrypted, nonce))
+
+    def _decrypt_AES_CFB(self, data, password):
+        encrypted, nonce = [unhexlify(part) for part in data.split(':')]
+        ctx = Cipher(password, nonce, 0, ciphername='aes-256-cfb')
+        return ctx.ciphering(encrypted)
+
+keystore = Keystore()
 
 
 def reloadMyAddressHashes():
@@ -107,7 +229,7 @@ def reloadMyAddressHashes():
     myECCryptorObjects.clear()
     myAddressesByHash.clear()
     myAddressesByTag.clear()
-    #myPrivateKeys.clear()
+    # myPrivateKeys.clear()
 
     keyfileSecure = checkSensitiveFilePermissions(state.appdata + 'keys.dat')
     hasEnabledKeys = False
@@ -115,26 +237,34 @@ def reloadMyAddressHashes():
         isEnabled = BMConfigParser().getboolean(addressInKeysFile, 'enabled')
         if isEnabled:
             hasEnabledKeys = True
-            status,addressVersionNumber,streamNumber,hash = decodeAddress(addressInKeysFile)
-            if addressVersionNumber == 2 or addressVersionNumber == 3 or addressVersionNumber == 4:
-                # Returns a simple 32 bytes of information encoded in 64 Hex characters,
-                # or null if there was an error.
-                privEncryptionKey = hexlify(decodeWalletImportFormat(
-                        BMConfigParser().get(addressInKeysFile, 'privencryptionkey')))
-
-                if len(privEncryptionKey) == 64:#It is 32 bytes encoded as 64 hex characters
-                    myECCryptorObjects[hash] = highlevelcrypto.makeCryptor(privEncryptionKey)
+            status, addressVersionNumber, streamNumber, hash = \
+                decodeAddress(addressInKeysFile)
+            if addressVersionNumber in (2, 3, 4):
+                # Returns a simple 32 bytes of information encoded
+                # in 64 Hex characters, or null if there was an error.
+                privEncryptionKey = keystore.fetch_key(addressInKeysFile)
+
+                # It is 32 bytes encoded as 64 hex characters
+                if len(privEncryptionKey) == 64:
+                    myECCryptorObjects[hash] = \
+                        highlevelcrypto.makeCryptor(privEncryptionKey)
                     myAddressesByHash[hash] = addressInKeysFile
-                    tag = hashlib.sha512(hashlib.sha512(encodeVarint(
-                        addressVersionNumber) + encodeVarint(streamNumber) + hash).digest()).digest()[32:]
+                    tag = hashlib.sha512(hashlib.sha512(
+                        encodeVarint(addressVersionNumber) +
+                        encodeVarint(streamNumber) + hash).digest()
+                    ).digest()[32:]
                     myAddressesByTag[tag] = addressInKeysFile
 
             else:
-                logger.error('Error in reloadMyAddressHashes: Can\'t handle address versions other than 2, 3, or 4.\n')
+                logger.error(
+                    'Error in reloadMyAddressHashes: Can\'t handle'
+                    ' address versions other than 2, 3, or 4.\n'
+                )
 
     if not keyfileSecure:
         fixSensitiveFilePermissions(state.appdata + 'keys.dat', hasEnabledKeys)
 
+
 def reloadBroadcastSendersForWhichImWatching():
     broadcastSendersForWhichImWatching.clear()
     MyECSubscriptionCryptorObjects.clear()
@@ -142,31 +272,43 @@ def reloadBroadcastSendersForWhichImWatching():
     logger.debug('reloading subscriptions...')
     for row in queryreturn:
         address, = row
-        status,addressVersionNumber,streamNumber,hash = decodeAddress(address)
+        status, addressVersionNumber, streamNumber, hash = \
+            decodeAddress(address)
         if addressVersionNumber == 2:
             broadcastSendersForWhichImWatching[hash] = 0
-        #Now, for all addresses, even version 2 addresses, we should create Cryptor objects in a dictionary which we will use to attempt to decrypt encrypted broadcast messages.
-        
+        # Now, for all addresses, even version 2 addresses,
+        # we should create Cryptor objects in a dictionary which we will
+        # use to attempt to decrypt encrypted broadcast messages.
+
         if addressVersionNumber <= 3:
-            privEncryptionKey = hashlib.sha512(encodeVarint(addressVersionNumber)+encodeVarint(streamNumber)+hash).digest()[:32]
-            MyECSubscriptionCryptorObjects[hash] = highlevelcrypto.makeCryptor(hexlify(privEncryptionKey))
+            privEncryptionKey = hashlib.sha512(
+                encodeVarint(addressVersionNumber) +
+                encodeVarint(streamNumber) + hash
+            ).digest()[:32]
+            MyECSubscriptionCryptorObjects[hash] = \
+                highlevelcrypto.makeCryptor(hexlify(privEncryptionKey))
         else:
-            doubleHashOfAddressData = hashlib.sha512(hashlib.sha512(encodeVarint(
-                addressVersionNumber) + encodeVarint(streamNumber) + hash).digest()).digest()
+            doubleHashOfAddressData = hashlib.sha512(hashlib.sha512(
+                encodeVarint(addressVersionNumber) +
+                encodeVarint(streamNumber) + hash
+            ).digest()).digest()
             tag = doubleHashOfAddressData[32:]
             privEncryptionKey = doubleHashOfAddressData[:32]
-            MyECSubscriptionCryptorObjects[tag] = highlevelcrypto.makeCryptor(hexlify(privEncryptionKey))
+            MyECSubscriptionCryptorObjects[tag] = \
+                highlevelcrypto.makeCryptor(hexlify(privEncryptionKey))
+
 
 def fixPotentiallyInvalidUTF8Data(text):
     try:
-        unicode(text,'utf-8')
+        unicode(text, 'utf-8')
         return text
     except:
-        output = 'Part of the message is corrupt. The message cannot be displayed the normal way.\n\n' + repr(text)
-        return output
+        return 'Part of the message is corrupt. The message cannot be' \
+           ' displayed the normal way.\n\n' + repr(text)
 
-# Checks sensitive file permissions for inappropriate umask during keys.dat creation.
-# (Or unwise subsequent chmod.)
+
+# Checks sensitive file permissions for inappropriate umask
+# during keys.dat creation. (Or unwise subsequent chmod.)
 #
 # Returns true iff file appears to have appropriate permissions.
 def checkSensitiveFilePermissions(filename):
@@ -181,14 +323,17 @@ def checkSensitiveFilePermissions(filename):
         return present_permissions & disallowed_permissions == 0
     else:
         try:
-            # Skip known problems for non-Win32 filesystems without POSIX permissions.
-            import subprocess
-            fstype = subprocess.check_output('stat -f -c "%%T" %s' % (filename),
-                                             shell=True,
-                                             stderr=subprocess.STDOUT)
+            # Skip known problems for non-Win32 filesystems
+            # without POSIX permissions.
+            fstype = subprocess.check_output(
+                'stat -f -c "%%T" %s' % (filename),
+                shell=True,
+                stderr=subprocess.STDOUT
+            )
             if 'fuseblk' in fstype:
-                logger.info('Skipping file permissions check for %s. Filesystem fuseblk detected.',
-                            filename)
+                logger.info(
+                    'Skipping file permissions check for %s.'
+                    ' Filesystem fuseblk detected.', filename)
                 return True
         except:
             # Swallow exception here, but we might run into trouble later!
@@ -197,27 +342,32 @@ def checkSensitiveFilePermissions(filename):
         disallowed_permissions = stat.S_IRWXG | stat.S_IRWXO
         return present_permissions & disallowed_permissions == 0
 
+
 # Fixes permissions on a sensitive file.
 def fixSensitiveFilePermissions(filename, hasEnabledKeys):
     if hasEnabledKeys:
-        logger.warning('Keyfile had insecure permissions, and there were enabled keys. '
-                       'The truly paranoid should stop using them immediately.')
+        logger.warning(
+            'Keyfile had insecure permissions, and there were enabled'
+            ' keys. The truly paranoid should stop using them immediately.')
     else:
-        logger.warning('Keyfile had insecure permissions, but there were no enabled keys.')
+        logger.warning(
+            'Keyfile had insecure permissions, but there were no enabled keys.'
+        )
     try:
         present_permissions = os.stat(filename)[0]
         disallowed_permissions = stat.S_IRWXG | stat.S_IRWXO
-        allowed_permissions = ((1<<32)-1) ^ disallowed_permissions
+        allowed_permissions = ((1 << 32) - 1) ^ disallowed_permissions
         new_permissions = (
             allowed_permissions & present_permissions)
         os.chmod(filename, new_permissions)
 
         logger.info('Keyfile permissions automatically fixed.')
 
-    except Exception, e:
+    except Exception:
         logger.exception('Keyfile permissions could not be fixed.')
         raise
-    
+
+
 def isBitSetWithinBitfield(fourByteString, n):
     # Uses MSB 0 bit numbering across 4 bytes of data
     n = 31 - n
@@ -227,39 +377,57 @@ def isBitSetWithinBitfield(fourByteString, n):
 
 def decryptAndCheckPubkeyPayload(data, address):
     """
-    Version 4 pubkeys are encrypted. This function is run when we already have the 
-    address to which we want to try to send a message. The 'data' may come either
-    off of the wire or we might have had it already in our inventory when we tried
-    to send a msg to this particular address. 
+    Version 4 pubkeys are encrypted. This function is run when we
+    already have the address to which we want to try to send a message.
+    The 'data' may come either off of the wire or we might have had it
+    already in our inventory when we tried to send a msg to this
+    particular address.
     """
     try:
         status, addressVersion, streamNumber, ripe = decodeAddress(address)
-        
+
         readPosition = 20  # bypass the nonce, time, and object type
-        embeddedAddressVersion, varintLength = decodeVarint(data[readPosition:readPosition + 10])
+        embeddedAddressVersion, varintLength = \
+            decodeVarint(data[readPosition:readPosition + 10])
         readPosition += varintLength
-        embeddedStreamNumber, varintLength = decodeVarint(data[readPosition:readPosition + 10])
+        embeddedStreamNumber, varintLength = \
+            decodeVarint(data[readPosition:readPosition + 10])
         readPosition += varintLength
-        storedData = data[20:readPosition] # We'll store the address version and stream number (and some more) in the pubkeys table.
-        
+        # We'll store the address version and stream number
+        # (and some more) in the pubkeys table.
+        storedData = data[20:readPosition]
+
         if addressVersion != embeddedAddressVersion:
-            logger.info('Pubkey decryption was UNsuccessful due to address version mismatch.')
+            logger.info(
+                'Pubkey decryption was UNsuccessful'
+                ' due to address version mismatch.')
             return 'failed'
         if streamNumber != embeddedStreamNumber:
-            logger.info('Pubkey decryption was UNsuccessful due to stream number mismatch.')
+            logger.info(
+                'Pubkey decryption was UNsuccessful'
+                ' due to stream number mismatch.')
             return 'failed'
-        
+
         tag = data[readPosition:readPosition + 32]
         readPosition += 32
-        signedData = data[8:readPosition] # the time through the tag. More data is appended onto signedData below after the decryption. 
+        # the time through the tag. More data is appended onto
+        # signedData below after the decryption.
+        signedData = data[8:readPosition]
         encryptedData = data[readPosition:]
-    
+
         # Let us try to decrypt the pubkey
         toAddress, cryptorObject = state.neededPubkeys[tag]
         if toAddress != address:
-            logger.critical('decryptAndCheckPubkeyPayload failed due to toAddress mismatch. This is very peculiar. toAddress: %s, address %s' % (toAddress, address))
-            # the only way I can think that this could happen is if someone encodes their address data two different ways.
-            # That sort of address-malleability should have been caught by the UI or API and an error given to the user. 
+            logger.critical(
+                'decryptAndCheckPubkeyPayload failed due to toAddress'
+                ' mismatch. This is very peculiar.'
+                ' toAddress: %s, address %s',
+                toAddress, address
+            )
+            # the only way I can think that this could happen
+            # is if someone encodes their address data two different ways.
+            # That sort of address-malleability should have been caught
+            # by the UI or API and an error given to the user.
             return 'failed'
         try:
             decryptedData = cryptorObject.decrypt(encryptedData)
@@ -268,90 +436,112 @@ def decryptAndCheckPubkeyPayload(data, address):
             # but tagged it with a tag for which we are watching.
             logger.info('Pubkey decryption was unsuccessful.')
             return 'failed'
-        
+
         readPosition = 0
-        bitfieldBehaviors = decryptedData[readPosition:readPosition + 4]
+        # bitfieldBehaviors = decryptedData[readPosition:readPosition + 4]
         readPosition += 4
-        publicSigningKey = '\x04' + decryptedData[readPosition:readPosition + 64]
+        publicSigningKey = \
+            '\x04' + decryptedData[readPosition:readPosition + 64]
         readPosition += 64
-        publicEncryptionKey = '\x04' + decryptedData[readPosition:readPosition + 64]
+        publicEncryptionKey = \
+            '\x04' + decryptedData[readPosition:readPosition + 64]
         readPosition += 64
-        specifiedNonceTrialsPerByte, specifiedNonceTrialsPerByteLength = decodeVarint(
-            decryptedData[readPosition:readPosition + 10])
+        specifiedNonceTrialsPerByte, specifiedNonceTrialsPerByteLength = \
+            decodeVarint(decryptedData[readPosition:readPosition + 10])
         readPosition += specifiedNonceTrialsPerByteLength
-        specifiedPayloadLengthExtraBytes, specifiedPayloadLengthExtraBytesLength = decodeVarint(
-            decryptedData[readPosition:readPosition + 10])
+        specifiedPayloadLengthExtraBytes, \
+            specifiedPayloadLengthExtraBytesLength = \
+            decodeVarint(decryptedData[readPosition:readPosition + 10])
         readPosition += specifiedPayloadLengthExtraBytesLength
         storedData += decryptedData[:readPosition]
         signedData += decryptedData[:readPosition]
-        signatureLength, signatureLengthLength = decodeVarint(
-            decryptedData[readPosition:readPosition + 10])
+        signatureLength, signatureLengthLength = \
+            decodeVarint(decryptedData[readPosition:readPosition + 10])
         readPosition += signatureLengthLength
         signature = decryptedData[readPosition:readPosition + signatureLength]
-        
-        if highlevelcrypto.verify(signedData, signature, hexlify(publicSigningKey)):
-            logger.info('ECDSA verify passed (within decryptAndCheckPubkeyPayload)')
-        else:
-            logger.info('ECDSA verify failed (within decryptAndCheckPubkeyPayload)')
+
+        if not highlevelcrypto.verify(
+                signedData, signature, hexlify(publicSigningKey)):
+            logger.info(
+                'ECDSA verify failed (within decryptAndCheckPubkeyPayload)')
             return 'failed'
-    
+
+        logger.info(
+            'ECDSA verify passed (within decryptAndCheckPubkeyPayload)')
+
         sha = hashlib.new('sha512')
         sha.update(publicSigningKey + publicEncryptionKey)
         ripeHasher = hashlib.new('ripemd160')
         ripeHasher.update(sha.digest())
         embeddedRipe = ripeHasher.digest()
-    
+
         if embeddedRipe != ripe:
-            # Although this pubkey object had the tag were were looking for and was
-            # encrypted with the correct encryption key, it doesn't contain the
-            # correct pubkeys. Someone is either being malicious or using buggy software.
-            logger.info('Pubkey decryption was UNsuccessful due to RIPE mismatch.')
+            # Although this pubkey object had the tag were were looking for
+            # and was encrypted with the correct encryption key,
+            # it doesn't contain the correct pubkeys. Someone is
+            # either being malicious or using buggy software.
+            logger.info(
+                'Pubkey decryption was UNsuccessful due to RIPE mismatch.')
             return 'failed'
-        
+
         # Everything checked out. Insert it into the pubkeys table.
-        
-        logger.info('within decryptAndCheckPubkeyPayload, addressVersion: %s, streamNumber: %s \n\
-                    ripe %s\n\
-                    publicSigningKey in hex: %s\n\
-                    publicEncryptionKey in hex: %s' % (addressVersion,
-                                                       streamNumber, 
-                                                       hexlify(ripe),
-                                                       hexlify(publicSigningKey),
-                                                       hexlify(publicEncryptionKey)
-                                                       )
-                    )
-    
+
+        logger.info(
+            'within decryptAndCheckPubkeyPayload, '
+            'addressVersion: %s, streamNumber: %s\nripe %s\n'
+            'publicSigningKey in hex: %s\npublicEncryptionKey in hex: %s',
+            addressVersion, streamNumber, hexlify(ripe),
+            hexlify(publicSigningKey), hexlify(publicEncryptionKey)
+        )
+
         t = (address, addressVersion, storedData, int(time.time()), 'yes')
         sqlExecute('''INSERT INTO pubkeys VALUES (?,?,?,?,?)''', *t)
         return 'successful'
-    except varintDecodeError as e:
-        logger.info('Pubkey decryption was UNsuccessful due to a malformed varint.')
+    except varintDecodeError:
+        logger.info(
+            'Pubkey decryption was UNsuccessful due to a malformed varint.')
         return 'failed'
-    except Exception as e:
-        logger.critical('Pubkey decryption was UNsuccessful because of an unhandled exception! This is definitely a bug! \n%s' % traceback.format_exc())
+    except Exception:
+        logger.critical(
+            'Pubkey decryption was UNsuccessful because of'
+            ' an unhandled exception! This is definitely a bug! \n%s' %
+            traceback.format_exc()
+        )
         return 'failed'
 
+
 def checkAndShareObjectWithPeers(data):
     """
-    This function is called after either receiving an object off of the wire
-    or after receiving one as ackdata. 
-    Returns the length of time that we should reserve to process this message
-    if we are receiving it off of the wire.
+    This function is called after either receiving an object
+    off of the wire or after receiving one as ackdata.
+    Returns the length of time that we should reserve to process
+    this message if we are receiving it off of the wire.
     """
     if len(data) > 2 ** 18:
-        logger.info('The payload length of this object is too large (%s bytes). Ignoring it.' % len(data))
+        logger.info(
+            'The payload length of this object is too large (%i bytes).'
+            ' Ignoring it.', len(data)
+        )
         return 0
     # Let us check to make sure that the proof of work is sufficient.
     if not protocol.isProofOfWorkSufficient(data):
         logger.info('Proof of work is insufficient.')
         return 0
-    
+
     endOfLifeTime, = unpack('>Q', data[8:16])
-    if endOfLifeTime - int(time.time()) > 28 * 24 * 60 * 60 + 10800: # The TTL may not be larger than 28 days + 3 hours of wiggle room
-        logger.info('This object\'s End of Life time is too far in the future. Ignoring it. Time is %s' % endOfLifeTime)
+    # The TTL may not be larger than 28 days + 3 hours of wiggle room
+    if endOfLifeTime - int(time.time()) > 28 * 24 * 60 * 60 + 10800:
+        logger.info(
+            'This object\'s End of Life time is too far in the future.'
+            ' Ignoring it. Time is %s', endOfLifeTime
+        )
         return 0
-    if endOfLifeTime - int(time.time()) < - 3600: # The EOL time was more than an hour ago. That's too much.
-        logger.info('This object\'s End of Life time was more than an hour ago. Ignoring the object. Time is %s' % endOfLifeTime)
+    # The EOL time was more than an hour ago. That's too much.
+    if endOfLifeTime - int(time.time()) < -3600:
+        logger.info(
+            'This object\'s End of Life time was more than an hour ago.'
+            ' Ignoring the object. Time is %s' % endOfLifeTime
+        )
         return 0
     intObjectType, = unpack('>I', data[16:20])
     try:
@@ -371,45 +561,59 @@ def checkAndShareObjectWithPeers(data):
             _checkAndShareUndefinedObjectWithPeers(data)
             return 0.6
     except varintDecodeError as e:
-        logger.debug("There was a problem with a varint while checking to see whether it was appropriate to share an object with peers. Some details: %s" % e)
-    except Exception as e:
-        logger.critical('There was a problem while checking to see whether it was appropriate to share an object with peers. This is definitely a bug! \n%s' % traceback.format_exc())
+        logger.debug(
+            'There was a problem with a varint while checking'
+            ' to see whether it was appropriate to share an object'
+            ' with peers. Some details: %s' % e)
+    except Exception:
+        logger.critical(
+            'There was a problem while checking to see whether it was'
+            ' appropriate to share an object with peers. This is'
+            ' definitely a bug! \n%s' % traceback.format_exc())
     return 0
-        
+
 
 def _checkAndShareUndefinedObjectWithPeers(data):
     embeddedTime, = unpack('>Q', data[8:16])
-    readPosition = 20 # bypass nonce, time, and object type
+    readPosition = 20  # bypass nonce, time, and object type
     objectVersion, objectVersionLength = decodeVarint(
         data[readPosition:readPosition + 9])
     readPosition += objectVersionLength
     streamNumber, streamNumberLength = decodeVarint(
         data[readPosition:readPosition + 9])
-    if not streamNumber in state.streamsInWhichIAmParticipating:
-        logger.debug('The streamNumber %s isn\'t one we are interested in.' % streamNumber)
+    if streamNumber not in state.streamsInWhichIAmParticipating:
+        logger.debug(
+            'The streamNumber %i isn\'t one we are interested in.',
+            streamNumber
+        )
         return
-    
+
     inventoryHash = calculateInventoryHash(data)
     if inventoryHash in Inventory():
-        logger.debug('We have already received this undefined object. Ignoring.')
+        logger.debug(
+            'We have already received this undefined object. Ignoring.')
         return
     objectType, = unpack('>I', data[16:20])
     Inventory()[inventoryHash] = (
-        objectType, streamNumber, data, embeddedTime,'')
-    logger.debug('advertising inv with hash: %s' % hexlify(inventoryHash))
-    protocol.broadcastToSendDataQueues((streamNumber, 'advertiseobject', inventoryHash))
-    
-    
+        objectType, streamNumber, data, embeddedTime, '')
+    logger.debug('advertising inv with hash: %s', hexlify(inventoryHash))
+    protocol.broadcastToSendDataQueues(
+        (streamNumber, 'advertiseobject', inventoryHash))
+
+
 def _checkAndShareMsgWithPeers(data):
     embeddedTime, = unpack('>Q', data[8:16])
-    readPosition = 20 # bypass nonce, time, and object type
-    objectVersion, objectVersionLength = decodeVarint(
-        data[readPosition:readPosition + 9])
+    readPosition = 20  # bypass nonce, time, and object type
+    objectVersion, objectVersionLength = \
+        decodeVarint(data[readPosition:readPosition + 9])
     readPosition += objectVersionLength
-    streamNumber, streamNumberLength = decodeVarint(
-        data[readPosition:readPosition + 9])
-    if not streamNumber in state.streamsInWhichIAmParticipating:
-        logger.debug('The streamNumber %s isn\'t one we are interested in.' % streamNumber)
+    streamNumber, streamNumberLength = \
+        decodeVarint(data[readPosition:readPosition + 9])
+    if streamNumber not in state.streamsInWhichIAmParticipating:
+        logger.debug(
+            'The streamNumber %i isn\'t one we are interested in.',
+            streamNumber
+        )
         return
     readPosition += streamNumberLength
     inventoryHash = calculateInventoryHash(data)
@@ -419,61 +623,73 @@ def _checkAndShareMsgWithPeers(data):
     # This msg message is valid. Let's let our peers know about it.
     objectType = 2
     Inventory()[inventoryHash] = (
-        objectType, streamNumber, data, embeddedTime,'')
-    logger.debug('advertising inv with hash: %s' % hexlify(inventoryHash))
-    protocol.broadcastToSendDataQueues((streamNumber, 'advertiseobject', inventoryHash))
+        objectType, streamNumber, data, embeddedTime, '')
+    logger.debug('advertising inv with hash: %s', hexlify(inventoryHash))
+    protocol.broadcastToSendDataQueues(
+        (streamNumber, 'advertiseobject', inventoryHash))
 
     # Now let's enqueue it to be processed ourselves.
-    objectProcessorQueue.put((objectType,data))
+    objectProcessorQueue.put((objectType, data))
+
 
 def _checkAndShareGetpubkeyWithPeers(data):
     if len(data) < 42:
-        logger.info('getpubkey message doesn\'t contain enough data. Ignoring.')
+        logger.info(
+            'getpubkey message doesn\'t contain enough data. Ignoring.')
         return
     embeddedTime, = unpack('>Q', data[8:16])
     readPosition = 20  # bypass the nonce, time, and object type
-    requestedAddressVersionNumber, addressVersionLength = decodeVarint(
-        data[readPosition:readPosition + 10])
+    requestedAddressVersionNumber, addressVersionLength = \
+        decodeVarint(data[readPosition:readPosition + 10])
     readPosition += addressVersionLength
-    streamNumber, streamNumberLength = decodeVarint(
-        data[readPosition:readPosition + 10])
-    if not streamNumber in state.streamsInWhichIAmParticipating:
-        logger.debug('The streamNumber %s isn\'t one we are interested in.' % streamNumber)
+    streamNumber, streamNumberLength = \
+        decodeVarint(data[readPosition:readPosition + 10])
+    if streamNumber not in state.streamsInWhichIAmParticipating:
+        logger.debug(
+            'The streamNumber %i isn\'t one we are interested in.',
+            streamNumber
+        )
         return
     readPosition += streamNumberLength
 
     inventoryHash = calculateInventoryHash(data)
     if inventoryHash in Inventory():
-        logger.debug('We have already received this getpubkey request. Ignoring it.')
+        logger.debug(
+            'We have already received this getpubkey request. Ignoring it.')
         return
 
     objectType = 0
     Inventory()[inventoryHash] = (
-        objectType, streamNumber, data, embeddedTime,'')
+        objectType, streamNumber, data, embeddedTime, '')
     # This getpubkey request is valid. Forward to peers.
-    logger.debug('advertising inv with hash: %s' % hexlify(inventoryHash))
-    protocol.broadcastToSendDataQueues((streamNumber, 'advertiseobject', inventoryHash))
+    logger.debug('advertising inv with hash: %s', hexlify(inventoryHash))
+    protocol.broadcastToSendDataQueues(
+        (streamNumber, 'advertiseobject', inventoryHash))
 
     # Now let's queue it to be processed ourselves.
-    objectProcessorQueue.put((objectType,data))
+    objectProcessorQueue.put((objectType, data))
+
 
 def _checkAndSharePubkeyWithPeers(data):
     if len(data) < 146 or len(data) > 440:  # sanity check
         return
     embeddedTime, = unpack('>Q', data[8:16])
     readPosition = 20  # bypass the nonce, time, and object type
-    addressVersion, varintLength = decodeVarint(
-        data[readPosition:readPosition + 10])
+    addressVersion, varintLength = \
+        decodeVarint(data[readPosition:readPosition + 10])
     readPosition += varintLength
-    streamNumber, varintLength = decodeVarint(
-        data[readPosition:readPosition + 10])
+    streamNumber, varintLength = \
+        decodeVarint(data[readPosition:readPosition + 10])
     readPosition += varintLength
-    if not streamNumber in state.streamsInWhichIAmParticipating:
-        logger.debug('The streamNumber %s isn\'t one we are interested in.' % streamNumber)
+    if streamNumber not in state.streamsInWhichIAmParticipating:
+        logger.debug(
+            'The streamNumber %i isn\'t one we are interested in.',
+            streamNumber
+        )
         return
     if addressVersion >= 4:
         tag = data[readPosition:readPosition + 32]
-        logger.debug('tag in received pubkey is: %s' % hexlify(tag))
+        logger.debug('tag in received pubkey is: %s', hexlify(tag))
     else:
         tag = ''
 
@@ -485,28 +701,34 @@ def _checkAndSharePubkeyWithPeers(data):
     Inventory()[inventoryHash] = (
         objectType, streamNumber, data, embeddedTime, tag)
     # This object is valid. Forward it to peers.
-    logger.debug('advertising inv with hash: %s' % hexlify(inventoryHash))
-    protocol.broadcastToSendDataQueues((streamNumber, 'advertiseobject', inventoryHash))
-
+    logger.debug('advertising inv with hash: %s', hexlify(inventoryHash))
+    protocol.broadcastToSendDataQueues(
+        (streamNumber, 'advertiseobject', inventoryHash))
 
     # Now let's queue it to be processed ourselves.
-    objectProcessorQueue.put((objectType,data))
+    objectProcessorQueue.put((objectType, data))
 
 
 def _checkAndShareBroadcastWithPeers(data):
     if len(data) < 180:
-        logger.debug('The payload length of this broadcast packet is unreasonably low. Someone is probably trying funny business. Ignoring message.')
+        logger.debug(
+            'The payload length of this broadcast packet is unreasonably low.'
+            ' Someone is probably trying funny business. Ignoring message.')
         return
     embeddedTime, = unpack('>Q', data[8:16])
     readPosition = 20  # bypass the nonce, time, and object type
-    broadcastVersion, broadcastVersionLength = decodeVarint(
-        data[readPosition:readPosition + 10])
+    broadcastVersion, broadcastVersionLength = \
+        decodeVarint(data[readPosition:readPosition + 10])
     readPosition += broadcastVersionLength
     if broadcastVersion >= 2:
-        streamNumber, streamNumberLength = decodeVarint(data[readPosition:readPosition + 10])
+        streamNumber, streamNumberLength = \
+            decodeVarint(data[readPosition:readPosition + 10])
         readPosition += streamNumberLength
-        if not streamNumber in state.streamsInWhichIAmParticipating:
-            logger.debug('The streamNumber %s isn\'t one we are interested in.' % streamNumber)
+        if streamNumber not in state.streamsInWhichIAmParticipating:
+            logger.debug(
+                'The streamNumber %i isn\'t one we are interested in.',
+                streamNumber
+            )
             return
     if broadcastVersion >= 3:
         tag = data[readPosition:readPosition+32]
@@ -514,24 +736,24 @@ def _checkAndShareBroadcastWithPeers(data):
         tag = ''
     inventoryHash = calculateInventoryHash(data)
     if inventoryHash in Inventory():
-        logger.debug('We have already received this broadcast object. Ignoring.')
+        logger.debug(
+            'We have already received this broadcast object. Ignoring.')
         return
     # It is valid. Let's let our peers know about it.
     objectType = 3
     Inventory()[inventoryHash] = (
         objectType, streamNumber, data, embeddedTime, tag)
     # This object is valid. Forward it to peers.
-    logger.debug('advertising inv with hash: %s' % hexlify(inventoryHash))
-    protocol.broadcastToSendDataQueues((streamNumber, 'advertiseobject', inventoryHash))
+    logger.debug('advertising inv with hash: %s', hexlify(inventoryHash))
+    protocol.broadcastToSendDataQueues(
+        (streamNumber, 'advertiseobject', inventoryHash))
 
     # Now let's queue it to be processed ourselves.
-    objectProcessorQueue.put((objectType,data))
+    objectProcessorQueue.put((objectType, data))
+
 
 def openKeysFile():
     if 'linux' in sys.platform:
-        import subprocess
         subprocess.call(["xdg-open", state.appdata + 'keys.dat'])
     else:
         os.startfile(state.appdata + 'keys.dat')
-
-from debug import logger
